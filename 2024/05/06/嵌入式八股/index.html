

<!DOCTYPE html>
<html lang="en" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png">
  <link rel="icon" href="/img/fluid.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="John Doe">
  <meta name="keywords" content="">
  
    <meta name="description" content="腾讯面经：算法：LRU(Least Recently Used) 是一种缓存淘汰机制，是一种根据数据的历史访问频率来淘汰数据的算法，而LRU-K是这种算法的变种之一，优先清理最近没有使用过的数据 LRU-K: LRU-K的主要目的是为了解决LRU算法“缓存污染”的问题，其核心思想是将“最近使用过1次”的判断标准扩展为“最近使用过K次”。也就是说没有到达K次访问的数据并不会被缓存，这也意味着需要对于">
<meta property="og:type" content="article">
<meta property="og:title" content="嵌入式八股">
<meta property="og:url" content="http://example.com/2024/05/06/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%85%AB%E8%82%A1/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="腾讯面经：算法：LRU(Least Recently Used) 是一种缓存淘汰机制，是一种根据数据的历史访问频率来淘汰数据的算法，而LRU-K是这种算法的变种之一，优先清理最近没有使用过的数据 LRU-K: LRU-K的主要目的是为了解决LRU算法“缓存污染”的问题，其核心思想是将“最近使用过1次”的判断标准扩展为“最近使用过K次”。也就是说没有到达K次访问的数据并不会被缓存，这也意味着需要对于">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="c:\Users\Administrator\AppData\Local\Temp{F589F9DC-FB0F-4f8a-99A7-8706075350F1}.png">
<meta property="og:image" content="c:\Users\Administrator\AppData\Local\Temp{8AA9C382-D2A2-4d40-AC47-B0A160CD5787}.png">
<meta property="og:image" content="c:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20240409142413758.png">
<meta property="og:image" content="c:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20240410104647697.png">
<meta property="og:image" content="c:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20240416191232599.png">
<meta property="article:published_time" content="2024-05-06T07:36:05.000Z">
<meta property="article:modified_time" content="2024-05-06T07:41:09.055Z">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="c:\Users\Administrator\AppData\Local\Temp{F589F9DC-FB0F-4f8a-99A7-8706075350F1}.png">
  
  
  
  <title>嵌入式八股 - Hexo</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.9.7","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":{"measurement_id":null},"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 7.2.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Fluid</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/" target="_self">
                <i class="iconfont icon-home-fill"></i>
                <span>Home</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/" target="_self">
                <i class="iconfont icon-archive-fill"></i>
                <span>Archives</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/" target="_self">
                <i class="iconfont icon-category-fill"></i>
                <span>Categories</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/" target="_self">
                <i class="iconfont icon-tags-fill"></i>
                <span>Tags</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/" target="_self">
                <i class="iconfont icon-user-fill"></i>
                <span>About</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="嵌入式八股"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2024-05-06 15:36" pubdate>
          May 6, 2024 pm
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          36k words
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          298 mins
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">嵌入式八股</h1>
            
            
              <div class="markdown-body">
                
                <h1 id="腾讯面经："><a href="#腾讯面经：" class="headerlink" title="腾讯面经："></a>腾讯面经：</h1><h1 id="算法："><a href="#算法：" class="headerlink" title="算法："></a>算法：</h1><p><em>LRU(Least Recently Used) 是一种缓存淘汰机制，是一种根据数据的历史访问频率来淘汰数据的算法，而LRU-K是这种算法的变种之一</em>，优先清理最近没有使用过的数据</p>
<p>LRU-K:</p>
<p>LRU-K的主要目的是为了解决LRU算法“缓存污染”的问题，其核心思想是将“最近使用过1次”的判断标准扩展为“最近使用过K次”。也就是说没有到达K次访问的数据并不会被缓存，这也意味着需要对于缓存数据的访问次数进行计数，当需要淘汰数据时，LRU-K会淘汰第K次访问时间距当前时间最大的数据。</p>
<p>具体实现：hashmap+双向链表</p>
<p>缓存污染：偶发性的、周期性的数据会导致LRU命中率急剧下降</p>
<p>其他的缓存淘汰机制：FIFO、LFU</p>
<h3 id="一万个数找出中位数，内存存不下所有数据怎么办"><a href="#一万个数找出中位数，内存存不下所有数据怎么办" class="headerlink" title="一万个数找出中位数，内存存不下所有数据怎么办"></a>一万个数找出中位数，内存存不下所有数据怎么办</h3><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs gradle">如果内存无法容纳所有数据，可以考虑使用一些外部排序算法，如归并排序（Merge <span class="hljs-keyword">Sort</span>）或堆排序（Heap <span class="hljs-keyword">Sort</span>），这些算法可以有效地在磁盘上对大量数据进行排序。<br><br>下面是一个简单的思路：<br><br>分块排序：将一万个数分成若干个较小的块，每个块的大小可以根据内存大小来确定。然后对每个块使用内存能够容纳的排序算法进行排序，如快速排序（Quick <span class="hljs-keyword">Sort</span>）。在排序完成后，将每个块的最小元素放入一个优先队列（最小堆）中。<br><br>选择中位数：从所有块的最小元素中选择第 n<span class="hljs-regexp">/2 小的元素作为初始的候选中位数。这个过程可以通过维护一个大小为 n/</span><span class="hljs-number">2</span> 的最小堆来实现，每次从最小堆中取出最小元素，并将对应块的下一个元素插入最小堆中。<br><br>更新候选中位数：重复上述步骤，直到最终找到中位数。这个过程会在每次选择过程中不断更新候选中位数，直到遍历完所有块。<br><br>通过这种方法，我们可以在不将所有数据同时加载到内存的情况下找到中位数。这种方式虽然需要额外的时间和空间来处理分块和维护候选中位数，但是可以有效地处理大量数据。<br></code></pre></td></tr></table></figure>



<h1 id="项目："><a href="#项目：" class="headerlink" title="项目："></a>项目：</h1><h2 id="嵌入式项目"><a href="#嵌入式项目" class="headerlink" title="嵌入式项目"></a>嵌入式项目</h2><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs smali">这个项目是一个基于STM32嵌入式实现智能家居控制系统，实现的功能模块包括温度、湿度、光照强度。可以实现当室内光线较暗时自动打开灯，当室内温度过高时红灯不停的闪烁，蜂鸣器也报警提醒主人室内温度过高要打开空调，当室内湿度过高时风扇开始工作，让室内湿度降下来，<br><br>具体流程是首先将ESP8266模块连接到MQTT服务器，之后在onenet上创建设备并登录，这样设备和单片机就相当于联通了，然后比如说控制LED，设备发送控制信息到onenet平台，平台转发信息到esp8266模块，esp8266模块通过串口将数据发送给单片机，单片机产生串口接受中断，中断服务程序将模块发送过来的数据放入环形缓冲区内，之后释放一个信号量，这会唤醒一个的解析进程，这个解析进程会解析出控制命令来控制LED，大概的流程就是这样<br></code></pre></td></tr></table></figure>

<p>遇到的问题：</p>
<figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf"><span class="hljs-number">1</span>：因为在发送数据的时候，需要先将数据保存起来，再取出数据进行读取，因此会频繁的利用数据，所以要采用一个高效的结构来保存数据，然后想到利用环形缓冲区，环形缓冲区的构建是先定义一个缓存buff，然后定义两个位置，一个读位置，一个写位置，本来判断环形缓冲区是否为空是要用读和写是否指向同一位置来判断的，但是为了防止读写冲突(也就是还没写完就相等)，设置了一个next_write，环形缓冲区的最后一位一般不用，当next_write <span class="hljs-operator">=</span> read时，缓冲区内就已满或者为空。<br><span class="hljs-number">2</span>：在点亮LED等的时候出现了一些问题，后来发现是一些引脚的默认功能不是GPIO功能，所以要先将引脚的默认功能关闭，然后设置为GPIO功能，<br></code></pre></td></tr></table></figure>

<p>如果智能家居收不到命令，可能是什么原因：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs">1：网络丢包<br>2：如果服务器负责监听订阅的进程崩溃了，那么客户端就收不到反馈，由于客户端由keepalive机制，会发送探测报文来查看服务器是否存活，如果经过一段时间的探测后，服务器没响应，则会断开连接。<br></code></pre></td></tr></table></figure>

<p>在点亮串口的时候发生了错误，因为发现引脚的默认功能不是GPIO功能，所以需要先将引脚的默认功能关闭，然后设置为GPIO功能</p>
<p>用XCOM来调试串口</p>
<p>ESP8266用AT命令实现很简单，一般不用管他，我们只需要发送几个AT指令告诉他干嘛就行，AT,AT+CWMOD,AT+CWDHCP,EPS8266+WIFI_INFO</p>
<p>可以去原理图中查看板子中的LED灯对应的引脚是哪个</p>
<h2 id="web服务器项目"><a href="#web服务器项目" class="headerlink" title="web服务器项目"></a>web服务器项目</h2><p>项目的介绍</p>
<figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs armasm">这个项目主要的目的是对浏览器的链接请求进行解析处理，处理完之后给浏览器客户端返回一个响应，如文字图片视频等。服务器后端的处理方式使用socket通信，利用epoll多路IO复用技术，可以同时处理多个请求，请求的解析使用预先准备好的线程池，使用reactor模式，主线程负责监听IO，获取io请求后把请求对象放入请求队列，交给工作线程。睡眠在请求队列上的工作线程被唤醒进行数据读取以及逻辑处理。利用正则与状态机来解析 Http 报文，支持 <span class="hljs-meta">GET</span>/POST 请求，支持长/短连接；并且使用基于小根堆的定时器关闭超时请求，解决超时，连接系统资源占用问题。<br><br>使用的是水平触发模式<br></code></pre></td></tr></table></figure>

<p>线程池是什么：</p>
<figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs gcode">线程池是由服务器预先创建的一组子线程，线程池中的线程数量应和CPU内核数量差不多，线程池中的所有子线程都运行着相同的代码，当有任务到来时，主线程会通过某种方式来选择一个子线程来实现这个任务<span class="hljs-comment">(就相当于✌的虚拟计算资源池)</span><br>好处：<br>省去了线程创建和销毁时耗费的资源和时间<br></code></pre></td></tr></table></figure>

<p>项目的功能</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-number">1</span>、利用IO多路复用技术Epoll与线程池实现了一个多线程的Reactor高并发模型； <br><span class="hljs-number">2</span>、利用正则与状态机解析HTTP请求报文，能够处理静态资源的请求；<br><span class="hljs-number">3</span>、实现同步/异步日志系统，记录服务器运行状态；<br><span class="hljs-number">4</span>、利用标准库容器封装<span class="hljs-type">char</span>，实现了自动增长的缓冲区； <br><span class="hljs-number">5</span>、基于堆结构实现定时器，关闭超时的非活动连接； <br></code></pre></td></tr></table></figure>

<p>项目的难点</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs">如何提高服务器的并发能力：<br>	1：最简单的，增加资源供给，给予更大的网络带宽，使用更高配置的服务器<br>	2：将请求分流：使用集群和分布式的系统架构 （集群是所有的服务器都有相同的功能，请求哪台都可以，主要起分流作用）<br>  （分布式是将不同的业务放到不同的服务器中，处理一个请求可能需要使用到多台服务器，起到加快请求处理的速度。）<br>  可以使用服务器集群和分布式架构，使得原本属于一个服务器的计算压力分散到多个服务器上。同时加快请求处理的速度。<br></code></pre></td></tr></table></figure>

<p>如果同时1000个客户端进行访问请求，线程数不多，怎么及时响应每一个请求？</p>
<figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs applescript">本项目是通过对子线程循环调用来解决高并发的问题的。<br><br>首先在创建线程的同时就调用了pthread_detach将线程进行分离，不用单独对工作线程进行回收，资源自动回收。<br><br>我们通过子线程的<span class="hljs-built_in">run</span>调用函数进行<span class="hljs-keyword">while</span>循环，让每一个线程池中的线程永远都不会停止，访问请求被封装到请求队列(<span class="hljs-built_in">list</span>)中，如果没有任务线程就 一直阻塞等待，有任务线程就 抢占式进行处理，直到请求队列为空，表示任务全部处理完成<br></code></pre></td></tr></table></figure>



<h1 id="计算机网络："><a href="#计算机网络：" class="headerlink" title="计算机网络："></a>计算机网络：</h1><h2 id="HTTPS了解吗，讲讲TLS-流程，"><a href="#HTTPS了解吗，讲讲TLS-流程，" class="headerlink" title="HTTPS了解吗，讲讲TLS 流程，"></a>HTTPS了解吗，讲讲TLS 流程，</h2><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs gcode">说HTTPS之前先说一下http协议，http协议是一种基于TCP协议的应用层传输协议，又因为HTTP在传输过程中是以明文形式传输，容易被攻击者窃听、篡改，HTTPS是在HTTP和TCP之间增加了一个SSL或者TLS安全传输协议，而HTTPS通过使用TLS或者SSL协议对数据进行加密和认证，提高了传输的安全性和保密性。<br>TLS的流程：TLS也是通过客户端和服务器端之间的握手来保证数据传输的安全性的。<br><br>HTTPS流程<br><span class="hljs-number">1</span>：首先客户端向服务端发送一个请求，并且连接到服务端的<span class="hljs-number">443</span>端口<br><span class="hljs-number">2</span>：之后，服务端会发送一个公钥<span class="hljs-comment">(证书)</span>过来<br><span class="hljs-number">3</span>：之后客户端解析这个公钥<span class="hljs-comment">(证书)</span>，查看这个证书是否有效，如果有效，那么就会生成一个随机值<span class="hljs-comment">(这个随机值就是密钥)</span>，之后用服务端发送过来的公钥来加密这个随机值<br><span class="hljs-number">4</span>：客户端发送这个加密过的随机值<br><span class="hljs-number">5</span>：服务端收到这个随机值之后，利用自己的私钥来解密，获得这个随机值，之后利用这个随机值来对称加密内容<br><span class="hljs-number">6</span>：之后就是http过程，进行传输数据<br>传输内容<br>客户端利用随机值来进行解密<br>这就是整个的过程<br><br>先非对称加密，在对称加密<br><br>TLS流程<br>TLS/SSL 的功能实现主要依赖于三类基本算法：散列函数 、对称加密和非对称加密<br>其利用非对称加密实现身份认证和密钥协商，对称加密算法采用协商的密钥对数据加密，基于散列函数验证信息的完整性。<br>所以HTTPS是使用对称加密和非对称加密两者并用的混合加密机制。<br>具体做法是：发送密文的一方使用对方的公钥进行加密处理“对称的密钥”，然后对方用自己的私钥解密拿到“对称的密钥”，这样可以确保交换的密钥是安全的前提下，使用对称加密方式进行通信。<br></code></pre></td></tr></table></figure>

<p><img src="C:\Users\Administrator\AppData\Local\Temp{F589F9DC-FB0F-4f8a-99A7-8706075350F1}.png" srcset="/img/loading.gif" lazyload alt="{F589F9DC-FB0F-4f8a-99A7-8706075350F1}"></p>
<h2 id="HTTP的长连接和短连接"><a href="#HTTP的长连接和短连接" class="headerlink" title="HTTP的长连接和短连接"></a>HTTP的长连接和短连接</h2><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs ruby"><span class="hljs-variable constant_">HTTP</span>协议的长连接和短连接，实质上是<span class="hljs-variable constant_">TCP</span>协议的长连接和短连接。<br>在<span class="hljs-variable constant_">HTTP</span>/<span class="hljs-number">1.0</span>中，默认使用的是短连接。也就是说，浏览器和服务器每进行一次<span class="hljs-variable constant_">HTTP</span>操作，就建立一次连接，任务结束就中断连接，也就是访问同一个服务器上的每一个资源，就要建立一个<span class="hljs-variable constant_">TCP</span>连接<br><br>但从 <span class="hljs-variable constant_">HTTP</span>/<span class="hljs-number">1.1</span>起，默认使用长连接，用以保持连接特性。使用长连接的<span class="hljs-variable constant_">HTTP</span>协议，会在请求和响应头加入这行代码：<span class="hljs-title class_">Connection</span><span class="hljs-symbol">:keep-alive</span>，就表示只建立一次<span class="hljs-variable constant_">TCP</span>连接，他有一个保持时间，可以继续利用这个<span class="hljs-variable constant_">TCP</span>连接来传输<span class="hljs-variable constant_">HTTP</span>数据<br></code></pre></td></tr></table></figure>



<h2 id="hTTP的常用状态码："><a href="#hTTP的常用状态码：" class="headerlink" title="hTTP的常用状态码："></a>hTTP的常用状态码：</h2><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-number">1</span>xx表示提示信息<br><br><span class="hljs-number">2</span>xx表示成功<br><span class="hljs-symbol">200 </span>ok（请求成功）<br><span class="hljs-symbol">204 </span>no content （请求成功，但是没有结果返回）<br><span class="hljs-symbol">206 </span>partial content （客户端请求一部分资源，服务端成功响应，返回一范围资源）<br><br><span class="hljs-number">3</span>xx表示重定向，网页或者资源位置发生变化，<br><span class="hljs-symbol">301 </span>move permanently （永久性重定向）<br><span class="hljs-symbol">302 </span>found （临时性重定向）<br><span class="hljs-symbol">303 </span>see other （示由于请求对应的资源存在着另一个 URI，应使用 <span class="hljs-keyword">GET</span>方法定向获取请求的资源）<br><span class="hljs-symbol">304 </span><span class="hljs-keyword">not</span> modified （表示在客户端采用带条件的访问某资源时，服务端找到了资源，但是这个请求的条件不符合。跟重定向无关）<br><span class="hljs-symbol">307 </span>temporary redirect （跟<span class="hljs-number">302</span>一个意思）<br><br><span class="hljs-number">4</span>xx表示客户端错误，请求报文有误<br><span class="hljs-symbol">400 </span>bad request （请求报文存在语法错误）<br><span class="hljs-symbol">401 </span>unauthorized （需要认证（第一次返回）或者认证失败（第二次返回））<br><span class="hljs-symbol">403 </span>forbidden （请求被服务器拒绝了）<br><span class="hljs-symbol">404 </span><span class="hljs-keyword">not</span> found （服务器上无法找到请求的资源）<br><br><span class="hljs-number">5</span>xx表示服务器错误<br><span class="hljs-symbol">500 </span>internal server <span class="hljs-keyword">error</span> （服务端执行请求时发生了错误）<br><span class="hljs-symbol">503 </span>service unavailable （服务器正在超负载或者停机维护，无法处理请求）<br></code></pre></td></tr></table></figure>

<h2 id="http中的get、post区别"><a href="#http中的get、post区别" class="headerlink" title="http中的get、post区别"></a>http中的get、post区别</h2><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">GET</span>和POST请求都是http的请求方式，用户通过不同的http的请求方式完成对资源（url）的不同操作。具体点来讲<span class="hljs-keyword">GET</span>一般用于获取/查询资源信息，而POST一般用于更新资源信息。<br><span class="hljs-number">1</span>、<span class="hljs-keyword">Get</span>请求提交的数据会在地址栏显示出来，而post请求不会再地址栏显示出来，<br><span class="hljs-number">2</span>、传输数据的大小：<span class="hljs-keyword">Get</span>请求由于浏览器对地址长度的限制而导致传输的数据有限制(因为他要将数据在地址栏显示出来)。而POST请求不会因为地址长度限制而导致传输数据限制。<br><span class="hljs-number">3</span>、安全性,POST的安全性要比<span class="hljs-keyword">GET</span>的安全性高。由于数据是会在地址中呈现，所以可以通过历史记录找到密码等关键信息。<br></code></pre></td></tr></table></figure>

<h2 id="http版本也很多了，http2和1-1有什么优势呢"><a href="#http版本也很多了，http2和1-1有什么优势呢" class="headerlink" title="http版本也很多了，http2和1.1有什么优势呢"></a>http版本也很多了，http2和1.1有什么优势呢</h2><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs mathematica">多路复用（<span class="hljs-variable">Multiplexing</span>）：<br>在 <span class="hljs-variable">HTTP</span><span class="hljs-operator">/</span><span class="hljs-number">1.1</span> 中，每个请求都需要通过单独的 <span class="hljs-variable">TCP</span> 连接发送，导致了<span class="hljs-string">&quot;队头阻塞&quot;</span>的问题，即一个请求在等待时会阻塞后续请求的发送。<br><span class="hljs-variable">HTTP</span><span class="hljs-operator">/</span><span class="hljs-number">2</span> 使用了多路复用技术，允许多个请求同时通过同一个 <span class="hljs-variable">TCP</span> 连接发送和接收，解决了队头阻塞的问题，提高了并发性能。<br>流量控制（<span class="hljs-variable">Flow</span> <span class="hljs-built_in">Control</span>）：<br>在 <span class="hljs-variable">HTTP</span><span class="hljs-operator">/</span><span class="hljs-number">1.1</span> 中，没有有效的机制来控制流量，可能导致服务器发送速度过快而导致客户端无法处理。<br><span class="hljs-variable">HTTP</span><span class="hljs-operator">/</span><span class="hljs-number">2</span> 使用了流量控制机制，允许客户端和服务器之间进行流量控制，保证了数据的平稳传输，防止了过载的情况发生。<br></code></pre></td></tr></table></figure>

<h2 id="http怎么进行传参"><a href="#http怎么进行传参" class="headerlink" title="http怎么进行传参"></a>http怎么进行传参</h2><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs stata">HTTP 协议本身并没有提供传参的机制，但在实际应用中，常用的传参方式包括在 URL 中使用查询字符串（<span class="hljs-keyword">query</span> string）、在请求体中使用表单数据等。以下是常见的 HTTP 传参方式：查询字符串(GET)和表单数据(<span class="hljs-keyword">POST</span>)<br><br>查询字符串（<span class="hljs-keyword">Query</span> String）：<br>查询字符串是指 URL 中问号后面的部分，例如 http:<span class="hljs-comment">//example.com/resource?param1=value1&amp;param2=value2。</span><br>查询字符串中的参数以键值对的形式出现，使用 key=value 的格式，多个参数之间使用 &amp; 符号分隔。<br>查询字符串适用于 GET 请求，客户端将参数直接附加在 URL 中发送给服务器。<br><br>表单数据（<span class="hljs-keyword">Form</span> Data）：<br>表单数据通常用于 <span class="hljs-keyword">POST</span> 请求，客户端将参数放在请求体中以表单形式提交给服务器。<br>在 HTML 表单中，可以使用 &lt;<span class="hljs-keyword">form</span>&gt; 标签包裹输入元素，用户填写表单后，提交时浏览器会将表单数据以键值对的形式发送给服务器。<br>服务器端可以通过解析请求体来获取表单数据，常见的编码方式包括 application/x-www-<span class="hljs-keyword">form</span>-urlencoded 和 multipart/<span class="hljs-keyword">form</span>-data。<br></code></pre></td></tr></table></figure>

<h2 id="URI和URL的区别"><a href="#URI和URL的区别" class="headerlink" title="URI和URL的区别"></a>URI和URL的区别</h2><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">（<span class="hljs-number">1</span>）URI(Uniform Resource Identifier)：统⼀资源标识符，可以唯⼀标识一个资源。<br>（<span class="hljs-number">2</span>）<span class="hljs-built_in">URL</span>(Uniform Resource Location)：统⼀资源定位符，可以提供该资源的路径。它是一种具体的URI，即<span class="hljs-built_in">URL</span>可以⽤来标识一个资源，⽽且还指明了如何定位到这个资源。<br>（<span class="hljs-number">3</span>）URI的作用像身份证号⼀样，<span class="hljs-built_in">URL</span>的作用更像家庭住址⼀样。<span class="hljs-built_in">URL</span>是⼀种具体的URI，它不仅唯一标识资源，⽽且还提供了定位该资源的信息。<br></code></pre></td></tr></table></figure>

<h2 id="Cookie和Session的区别"><a href="#Cookie和Session的区别" class="headerlink" title="Cookie和Session的区别"></a>Cookie和Session的区别</h2><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">cookie和<span class="hljs-keyword">session</span>是为了进行身份辨认的<br>保存位置不同，Cookie保存在客户端，<span class="hljs-keyword">Session</span>保存在服务端；<br>隐私策略不同，Cookie 可以减轻服务器压力，但是不安全，容易进行Cookie 欺骗，<span class="hljs-keyword">Session</span>较安全，但占用服务器资源；<br>有效期不同，Cookie 可设置为长时间保持，比如经常使用的默认登录功能，<span class="hljs-keyword">Session</span>一般失效时间较短，客户端关闭或者<span class="hljs-keyword">Session</span>超时都会失效。<br><br></code></pre></td></tr></table></figure>

<p>如果禁用cookie，session还能用吗</p>
<figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">可以，Session的作用是在服务端保持状态，通过sessionid来进行确认身份，但sessionid一般是通过Cookie来进行传递的。如果Cooike被禁用了，可以通过在<span class="hljs-built_in">URL</span>中传递sessionid。<br></code></pre></td></tr></table></figure>



<h2 id="安全通信的四大原则"><a href="#安全通信的四大原则" class="headerlink" title="安全通信的四大原则"></a>安全通信的四大原则</h2><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs">机密性，对数据进行加密<br>完整性：数据在传输过程中没有经过篡改<br>身份认证：确认对方的身份<br>不可否认：传输了之后，不能否认自己传输过数据<br></code></pre></td></tr></table></figure>

<h2 id="CA-签发流程"><a href="#CA-签发流程" class="headerlink" title="CA 签发流程"></a>CA 签发流程</h2><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">1</span>.申请认证, <span class="hljs-number">2</span>.审核信息, <span class="hljs-number">3</span>.签发证书 <span class="hljs-number">4</span>.返回证书 <span class="hljs-number">5</span>.验证证书 <span class="hljs-number">6</span>.密钥协商 <br></code></pre></td></tr></table></figure>

<h2 id="讲一下tcp协议握手协议"><a href="#讲一下tcp协议握手协议" class="headerlink" title="讲一下tcp协议握手协议"></a>讲一下tcp协议握手协议</h2><p><img src="C:\Users\Administrator\AppData\Local\Temp{8AA9C382-D2A2-4d40-AC47-B0A160CD5787}.png" srcset="/img/loading.gif" lazyload alt="{8AA9C382-D2A2-4d40-AC47-B0A160CD5787}"></p>
<h2 id="TCP分为三次握手和四次挥手："><a href="#TCP分为三次握手和四次挥手：" class="headerlink" title="TCP分为三次握手和四次挥手："></a>TCP分为三次握手和四次挥手：</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-code">	三次握手</span><br><span class="hljs-code"></span><br>​	在TCP连接过程中为了建立端到端的连接，需要进行TCP的三次握手过程，首先，服务器处于监听阶段，客户端发来一个SYN包到服务器，表示自己想要建立连接，之后服务器会发送一个SYN和ACK包来确认收到请求并允许建立连接，之后客户端再发送一个ACK包表示已经收到服务器的回复，并同意建立可靠连接。<br><br>​	四次挥手：<br><br>​	首先客户端发送一个FIN包表示自己想要关闭连接，之后服务器会发送一个ACK确认包到客户端，表示同意关闭连接，之后等服务器向客户端传递的数据传输完毕之后，服务器再发送一个FIN+ACK包来表示自己的数据已经发送完毕，请求关闭连接，客户端再发送一个ACK确认包来回复服务器表示同意关闭<br></code></pre></td></tr></table></figure>

<h2 id="TCP三次握手中的序号和确认序号有什么用？"><a href="#TCP三次握手中的序号和确认序号有什么用？" class="headerlink" title="TCP三次握手中的序号和确认序号有什么用？"></a>TCP三次握手中的序号和确认序号有什么用？</h2><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs">保证了接受数据的完整性和有序性<br><br>如何保证完整性的？<br>当生成了一个序号并随着TCP报文段发送出去之后，服务端要发送一个确认号回来，这个确认号表示下一个想要接收到的序号，如果接收到的不是这个序号的报文段，那么就丢弃<br></code></pre></td></tr></table></figure>

<h2 id="TCP与UDP的区别："><a href="#TCP与UDP的区别：" class="headerlink" title="TCP与UDP的区别："></a>TCP与UDP的区别：</h2><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">TCP</span>是面向连接的，UDP是无连接的<br><span class="hljs-attribute">TCP</span>是可靠的，UDP是不可靠的<br><span class="hljs-attribute">TCP</span>是面向字节流的，UDP是面向数据报文的<br><span class="hljs-attribute">TCP</span>只支持点对点通信，UDP支持一对一，一对多，多对多<br><span class="hljs-attribute">TCP</span>报文首部<span class="hljs-number">20</span>个字节，UDP首部<span class="hljs-number">8</span>个字节<br><span class="hljs-attribute">TCP</span>有拥塞控制机制，UDP没有<br></code></pre></td></tr></table></figure>

<h2 id="讲一下向某个网站从发送请求到收到数据这个过程中发生的事情。"><a href="#讲一下向某个网站从发送请求到收到数据这个过程中发生的事情。" class="headerlink" title="讲一下向某个网站从发送请求到收到数据这个过程中发生的事情。"></a>讲一下向某个网站从发送请求到收到数据这个过程中发生的事情。</h2><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs css">浏览器进行DNS域名解析，得到对应的IP地址<br>根据这个IP和默认端口<span class="hljs-number">80</span>，和对应的服务器建立TCP连接（三次握手）<br>建立TCP连接后发起HTTP请求（一个完整的http请求报文）<br>服务器响应HTTP请求，浏览器得到<span class="hljs-selector-tag">html</span>代码（服务器如何响应）<br>浏览器解析<span class="hljs-selector-tag">html</span>代码，并请求<span class="hljs-selector-tag">html</span>代码中的资源（如js、css、图片等）<br>浏览器对页面进行渲染呈现给用户<br>服务器关闭TCP连接（四次挥手）<br></code></pre></td></tr></table></figure>

<h2 id="http和htpps的区别"><a href="#http和htpps的区别" class="headerlink" title="http和htpps的区别"></a>http和htpps的区别</h2><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs autohotkey">HTTP和HTTPS是用于在客户端和服务器之间传输数据的两种协议。它们的主要区别在于安全性和加密方面：<br><br>   <span class="hljs-number">1</span>. `安全性`：HTTP是一种不安全的协议，数据在传输过程中以明文形式传输，容易被攻击者窃听、篡改或伪装。而HTTPS通过使用TLS（Transport Layer Security）或SSL（Secure Sockets Layer）协议对数据进行加密和认证，提供了更高的安全性和保密性。<br><br>   <span class="hljs-number">2</span>. `加密通信`：HTTP不提供数据的加密传输，使得敏感信息（如登录凭据、信用卡号等）容易被攻击者获取。而HTTPS使用SSL/TLS协议对通信进行加密，确保数据在传输过程中的机密性，使得攻击者无法轻易获取敏感信息。<br><br>   <span class="hljs-number">3</span>. `证书验证`：HTTPS使用SSL/TLS证书对服务器进行身份验证，确保客户端与服务器之间的通信建立在可信任的连接上。客户端会验证服务器的证书，以确保与合法和受信任的服务器建立连接。这样可以防止中间人攻击和DNS劫持等安全威胁。<br><br>   <span class="hljs-number">4</span>. `默认端口`：HTTP使用端口号<span class="hljs-number">80</span>进行通信，而HTTPS使用端口号<span class="hljs-number">443</span>进行加密通信。<br><br>HTTPS在保护用户隐私和数据安全方面比HTTP更加可靠，因此在需要保护敏感信息的场景，如电子商务网站、在线支付平台等，推荐使用HTTPS。<br></code></pre></td></tr></table></figure>

<h2 id="http没那么安全的例子？"><a href="#http没那么安全的例子？" class="headerlink" title="http没那么安全的例子？"></a>http没那么安全的例子？</h2><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">因为HTTP来传输的时候是使用明文来进行传输的，而明文很容易就被心怀不轨者所窃听，篡改或伪装，所以<span class="hljs-keyword">http</span>并不安全<br></code></pre></td></tr></table></figure>

<h2 id="tcp三次握手和四次挥手的过程中，双端是怎样变化的"><a href="#tcp三次握手和四次挥手的过程中，双端是怎样变化的" class="headerlink" title="tcp三次握手和四次挥手的过程中，双端是怎样变化的"></a>tcp三次握手和四次挥手的过程中，双端是怎样变化的</h2><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc">三次握手：<br>1.客户端向服务器发送SYN包，并进入SYN_SENT状态，等待服务器确认；<br><br>2.服务器收到SYN包并进行确认，同时向客户端发送SYN包，即SYN+ACK包。此时服务器进入SYN_RECV状态。<br><br>3.客户端收到服务器的SYN+ACK包后，向服务器发送确认包ACK，发送完毕后，TCP连接成功，完成三次握手。<br><br>四次挥手：<br>1.首先客户端发送一个FIN包表示自己想要关闭连接，客户端进入FIN<span class="hljs-emphasis">_CLOSE1状态</span><br><span class="hljs-emphasis">2之后服务器会发送一个ACK确认包到客户端，表示同意关闭连接，服务器进入CLOSE_WAIT状态，客户端进入FIN_CLOSE2状态</span><br><span class="hljs-emphasis">3之后等服务器向客户端传递的数据传输完毕之后，服务器再发送一个FIN+ACK包来表示自己的数据已经发送完毕，请求关闭连接，服务器进入LAST_ACK状态</span><br><span class="hljs-emphasis">4客户端再发送一个ACK确认包来回复服务器表示同意关闭，客户端进入TIME_</span>WAIT状态<br></code></pre></td></tr></table></figure>

<h2 id="FIN标记一定要程序执行close-或者shutdown-才能发出吗"><a href="#FIN标记一定要程序执行close-或者shutdown-才能发出吗" class="headerlink" title="FIN标记一定要程序执行close()或者shutdown()才能发出吗"></a>FIN标记一定要程序执行close()或者shutdown()才能发出吗</h2><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs perl">不一定。一般情况下，通过对<span class="hljs-keyword">socket</span>执行<span class="hljs-keyword">close</span>() 或<span class="hljs-keyword">shutdown</span>()方法会发出FIN。<br>但实际上，只要应用程序退出，不管是主动退出，还是被动退出（因为一些莫名其妙的原因被<span class="hljs-keyword">kill</span>了）, 都会发出FIN。FIN 是指<span class="hljs-string">&quot;我不再发送数据&quot;</span>，因此<span class="hljs-keyword">shutdown</span>()关闭读不会给对方发FIN, 关闭写才会发FIN。<br></code></pre></td></tr></table></figure>

<h2 id="TCP挥手可以三次吗，两次可以吗"><a href="#TCP挥手可以三次吗，两次可以吗" class="headerlink" title="TCP挥手可以三次吗，两次可以吗"></a>TCP挥手可以三次吗，两次可以吗</h2><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs armasm">都可以<br>挥手三次：如果被动关闭方没有数据要发送时，那么第二次挥手和第三次挥手可以合并，合并之后就是三次挥手了<br><br>挥手两次：如果客户端和服务端的<span class="hljs-built_in">IP</span>和端口都是一样的<br></code></pre></td></tr></table></figure>

<h2 id="黑客想要通过TCP攻击，会如何攻击，应该怎样应对"><a href="#黑客想要通过TCP攻击，会如何攻击，应该怎样应对" class="headerlink" title="黑客想要通过TCP攻击，会如何攻击，应该怎样应对"></a>黑客想要通过TCP攻击，会如何攻击，应该怎样应对</h2><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs armasm">因为TCP需要经过三次握手过程才可以建立连接，黑客们一般会通过伪装大量的<span class="hljs-built_in">IP</span>地址给服务器发送SYN请求连接报文，但是由于<span class="hljs-built_in">IP</span>地址不存在，因此当服务器给客户端发送回确认之后，由于一直收不到确认，会一直处于SYN_RECV状态，服务器会将<span class="hljs-built_in">IP</span>放入等待队列，并重发确认报文，而由于攻击者发送了大量的请求报文，会导致服务器要维持一个很大的等待队列，导致服务器崩溃<br></code></pre></td></tr></table></figure>

<h2 id="讲一下三次握手，两次行不行"><a href="#讲一下三次握手，两次行不行" class="headerlink" title="讲一下三次握手，两次行不行"></a>讲一下三次握手，两次行不行</h2><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs">两次握手相比较于三次握手可能会出现一些问题，最主要的原因在于三次握手可以避免重复历史连接<br>主要是两次握手在服务端收到客户端发来的请求连接报文后，就会立即建立连接，而这可能会导致一些迟来的请求连接造成无效的连接，浪费资源。<br></code></pre></td></tr></table></figure>

<h2 id="讲一下time-wait状态"><a href="#讲一下time-wait状态" class="headerlink" title="讲一下time_wait状态"></a>讲一下time_wait状态</h2><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc">time<span class="hljs-emphasis">_wait是客户端在收到服务器发来数据已经传送完成并且请求关闭连接之后，客户端发送确认报文，就进入了time_wait状态，这个状态主要是为了保证连接正确关闭，例如当主动关闭方发送的确认报文丢失了，那么被动方会重新发送一个请求报文，所以设置一个time_wait是有必要的</span><br><span class="hljs-emphasis">另外，如果不设置这个time_</span>wait当又有新的连接在这两个端口连接时，如果有上一个链接迟来的报文到达，会导致数据错乱(可以保证旧连接重复分组已经在网络中消逝)<br></code></pre></td></tr></table></figure>

<h2 id="那假设A服务器开了8080端口，B服务器用什么命令去访问"><a href="#那假设A服务器开了8080端口，B服务器用什么命令去访问" class="headerlink" title="那假设A服务器开了8080端口，B服务器用什么命令去访问"></a>那假设A服务器开了8080端口，B服务器用什么命令去访问</h2><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs css">可以使用netstat来查看哪些端口被打开<br>可以直接使用ssh来直接登录<span class="hljs-selector-tag">b</span>服务器<br></code></pre></td></tr></table></figure>

<h2 id="了解滑动窗口吗"><a href="#了解滑动窗口吗" class="headerlink" title="了解滑动窗口吗"></a>了解滑动窗口吗</h2><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs excel">TCP的滑动窗口是一种核心的流量控制机制。它基于窗口的概念，窗口实际上是一个缓冲区，在这个缓冲区内，发送方被允许在未收到确认的情况下连续发送数据，其中发送窗口就表示接收方还剩下多少接收缓冲<br>滑动窗口分为三类：停止等待、后退<span class="hljs-built_in">N</span>帧、选择重传，他们之间的区别就在于发送窗口和接收窗口的区别，<br>停止等待：发送窗口=<span class="hljs-number">1</span>，接收窗口=<span class="hljs-number">1</span><br>后退<span class="hljs-built_in">N</span>帧：发送窗口&gt;=<span class="hljs-number">1</span>，接收窗口=<span class="hljs-number">1</span>，允许在未收到确认帧时发送后面的帧，但是当接收方发现接收到错误帧，那么后面发来的全部帧全部不要<br>选择重传：发送窗口&gt;=<span class="hljs-number">1</span>,接收窗口&gt;=<span class="hljs-number">1</span>，在后退<span class="hljs-built_in">N</span>帧基础上，在缓存中保存了错误帧后面的帧，等到重传的正确帧到来后一起上传<br></code></pre></td></tr></table></figure>

<h2 id="那你讲一下拥塞控制的方法"><a href="#那你讲一下拥塞控制的方法" class="headerlink" title="那你讲一下拥塞控制的方法"></a>那你讲一下拥塞控制的方法</h2><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs abnf">慢开始，拥塞避免，快重传，快恢复<br>慢开始是指在传输刚开始时，拥塞窗口<span class="hljs-operator">=</span><span class="hljs-number">1</span>，然后发送方每收到一个确认报文，拥塞窗口都会加一，为了防止拥塞窗口过大而导致网络拥塞，设置一个慢开始门限，小于门限使用满开始，高于门限，则使用拥塞避免，表示拥塞窗口每次只加一<br>当遇到拥塞时，门限减为原来的一半，拥塞窗口从<span class="hljs-number">1</span>开始<br>快重传表示如果发送方连续接收到了<span class="hljs-number">3</span>个重复确认，那么立即重传要求的报文<br>快恢复表示在快重传之后，不是执行慢开始而是执行快恢复，将拥塞窗口和门限都除以二，执行拥塞避免<br></code></pre></td></tr></table></figure>

<h2 id="拥塞控制与流量控制："><a href="#拥塞控制与流量控制：" class="headerlink" title="拥塞控制与流量控制："></a>拥塞控制与流量控制：</h2><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">拥塞控制是一种全局的问题，而流量控制往往指点到点通信量的控制，是一种端到端的<br></code></pre></td></tr></table></figure>

<h2 id="RPC是什么"><a href="#RPC是什么" class="headerlink" title="RPC是什么"></a>RPC是什么</h2><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs delphi">RPC（Remote <span class="hljs-function"><span class="hljs-keyword">Procedure</span> <span class="hljs-title">Call</span>）远程过程调用协议，一种通过网络从远程计算机上请求服务，而不需要了解底层网络技术的协议。在<span class="hljs-title">OSI</span>网络七层模型中，<span class="hljs-title">RPC</span>跨越了传输层和应用层。</span><br></code></pre></td></tr></table></figure>

<h2 id="arp协议"><a href="#arp协议" class="headerlink" title="arp协议"></a>arp协议</h2><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs armasm">是一个数据链路层协议，数据链路层使用arp协议来进行寻址，当数据链路层收到了网络层传下来的数据包后，根据<span class="hljs-built_in">IP</span>地址，首先查看自己的arp缓存中有没有目的<span class="hljs-built_in">IP</span>地址对应的MAC地址，如果有，那么就利用这个MAC地址建立通信，如果没有，那么就向局域网内发送arp请求广播，局域网内所有的主机都能听到，局域网内的主机检查发来的arp广播中的目的<span class="hljs-built_in">IP</span>地址是否与自己的<span class="hljs-built_in">IP</span>地址一致，如果一致，那么主机就发送一个ARP响应，包含自己的MAC地址，这个响应也是以广播方式发送，请求主机收到响应后，他将更新arp缓存，将目标<span class="hljs-built_in">IP</span>地址和MAC地址更新，之后就根据MAC地址建立连接<br></code></pre></td></tr></table></figure>

<h2 id="ip协议"><a href="#ip协议" class="headerlink" title="ip协议"></a>ip协议</h2><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs armasm">在网络层使用<span class="hljs-built_in">ip</span>协议来进行寻址，<span class="hljs-built_in">ip</span>地址是分配给计算机或者网络设备的唯一标识符，在<span class="hljs-built_in">IP</span>协议中，每个数据包中都包含目的地址和源地址，使得数据能够在网络中正确的传递<br></code></pre></td></tr></table></figure>

<h2 id="TCP是可靠传输，我们在编程的时候相比UDP是不是要绑定端口这些？"><a href="#TCP是可靠传输，我们在编程的时候相比UDP是不是要绑定端口这些？" class="headerlink" title="TCP是可靠传输，我们在编程的时候相比UDP是不是要绑定端口这些？"></a>TCP是可靠传输，我们在编程的时候相比UDP是不是要绑定端口这些？</h2><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs scss">在使用socket编程时：<br>无论是TCP还是UDP，在编程时都需要绑定端口，这是因为套接字（Socket）通信是通过端口来识别应用程序和服务的。<br>无论是TCP还是UDP编程，通常都需要进行以下步骤：<br><br>创建套接字：使用<span class="hljs-built_in">socket</span>()函数创建套接字。<br>绑定端口：使用<span class="hljs-built_in">bind</span>()函数将套接字绑定到特定的端口上，这样其他程序就可以通过指定的端口来与该程序通信。<br>监听连接（仅适用于TCP）：如果是TCP编程，还需要调用<span class="hljs-built_in">listen</span>()函数开始监听传入的连接请求。<br>接受连接（仅适用于TCP）：如果是TCP编程，还需要调用<span class="hljs-built_in">accept</span>()函数接受传入的连接请求，建立连接。<br>发送和接收数据：使用<span class="hljs-built_in">send</span>()和<span class="hljs-built_in">recv</span>()（或者<span class="hljs-built_in">sendto</span>()和<span class="hljs-built_in">recvfrom</span>()）函数进行数据的发送和接收。<br>在TCP编程中，因为TCP是面向连接的协议，所以需要额外的步骤来监听连接和接受连接，这些步骤不适用于UDP编程。但是无论是TCP还是UDP，都需要在编程中绑定端口，以便程序能够通过特定的端口进行通信。<br></code></pre></td></tr></table></figure>

<p>socket编程，TCP和UDP在API层面主要有哪些区别？</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs perl">首先在创建套接字时，利用<span class="hljs-keyword">socket</span>函数，TCP使用sock_STREAM参数，UDP使用SOCK_DGRAM参数<br>tcp需要使用<span class="hljs-keyword">connect</span>函数来建立链接，UDP不需要建立连接，直接发送制定目标IP地址和端口号<br>TCP使用<span class="hljs-keyword">send</span>函数发送数据，UDP使用sendto函数发送数据<br>TCP使用<span class="hljs-keyword">recv</span>函数接收数据，UDP使用recvfrom函数接收数据<br></code></pre></td></tr></table></figure>

<p>TCP是怎么实现可靠传输的</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs">TCP的三次握手，四次挥手<br>TCP提供了检验和，并且有序列号和确认应答机制<br>TCP有拥塞控制和滑动窗口机制<br></code></pre></td></tr></table></figure>

<p>非对称加密算法和对称加密算法</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">对称密码体制设计和实现的中心是: 用何种方法产生满足保密要求的密钥以及用何种方法将密钥安全又可靠地分配给通信双方。对称密码体制可以通过分组密码或流密码来实现，它既可以用于数据加密，又可以用于消息认证。</span><br>非对称密码体制使用公钥加密消息，使用私钥来解密。使用非对称密码体制可增强通信的安全性。<br></code></pre></td></tr></table></figure>



<h1 id="操作系统："><a href="#操作系统：" class="headerlink" title="操作系统："></a>操作系统：</h1><h2 id="进程调度算法"><a href="#进程调度算法" class="headerlink" title="进程调度算法"></a>进程调度算法</h2><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc">时间片轮转<br>将所有就绪进程按到来的顺序排成一个队列，每次调度时，把 CPU 时间分配给队首进程，该进程可以执行一个时间片。<br>当时间片用完时，由计时器发出时钟中断，调度程序便停止该进程的执行，并将它送往就绪队列的末尾，同时继续把 CPU 时间分配给就绪队列队首的进程。<br><br>难点：时间片的大小的选择<br><span class="hljs-bullet">- </span>如果时间片太小，会导致进程切换得太频繁，在进程切换上就会花过多时间。<br><span class="hljs-bullet">- </span>而如果时间片过长，那么实时性就不能得到保证。<br><br>优先级调度<br>为每个进程分配一个优先级，按优先级进行调度。为了防止低优先级的进程永远等不到调度，可以随着时间的推移增加等待进程的优先级。<br><br>先来先服务<br>非抢占式的调度算法，按照进程请求的顺序进行调度。<br><br>缺点：有利于长作业，但不利于短作业<br></code></pre></td></tr></table></figure>

<h2 id="进程线程间通信方式"><a href="#进程线程间通信方式" class="headerlink" title="进程线程间通信方式"></a>进程线程间通信方式</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs markdown">进程间通信方式：<br>管道、套接字、信号量、共享内存、消息队列<br><span class="hljs-bullet">-</span> 管道：<br><span class="hljs-bullet">  -</span> 无名管道：管道是一种半双工的通信方式，数据只能单向流动，而且只能在具有亲缘关系的进程之间使用。<br><span class="hljs-bullet">  -</span> 有名管道：有名管道也是半双工的通信方式，但是允许在没有亲缘关系的进程之间使用，管道是先进先出的通信方式。<br><span class="hljs-bullet">-</span> 共享内存：共享内存就是映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问。共享内存是最快的IPC方式。<br><span class="hljs-bullet">-</span> 消息队列：消息队列是有消息的链表，存放在内核中并由消息队列标识符标识。<br><span class="hljs-bullet">-</span> 信号量：信号量是一个计数器，可以用来控制多个进程对共享资源的访问。<br><span class="hljs-bullet">-</span> 套接字：适用于不同机器间进程通信，在本地也可作为两个进程通信的方式。<br><br>线程间通信方式：<br>信号、条件变量<br></code></pre></td></tr></table></figure>

<h2 id="进程线程同步机制"><a href="#进程线程同步机制" class="headerlink" title="进程线程同步机制"></a>进程线程同步机制</h2><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc">进程同步方式：<br>临界区：对临界资源进行访问的代码成为临界区;<br>同步与互斥<br>信号量：信号量表示有多少进程可以同时访问这片共享资源；<br>互斥量：就是信号量的取值只能为0或1；<br><br>线程同步方式：<br><span class="hljs-bullet">- </span>信号量：可用于进程同步，也可用于线程同步。<br><span class="hljs-bullet">- </span>互斥锁 + 条件变量：只能用于线程同步。<br></code></pre></td></tr></table></figure>

<h2 id="进程的五种状态"><a href="#进程的五种状态" class="headerlink" title="进程的五种状态"></a>进程的五种状态</h2><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">创建、就绪、运行、阻塞、结束<br></code></pre></td></tr></table></figure>



<h2 id="进程、线程和协程的区别和联系"><a href="#进程、线程和协程的区别和联系" class="headerlink" title="进程、线程和协程的区别和联系"></a>进程、线程和协程的区别和联系</h2><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs">进程是资源分配的基本单位，它是程序执行时的一个实例，在程序运行时创建。<br><br>线程是程序执行的最小单位，是进程的一个执行流，一个线程由多个线程组成的。<br><br>协程是一种比线程更加轻量级的存在，完全由程序控制，他可以在不同的执行流之间切换，但不涉及操作系统的线程调度和上下文切换，所以会比线程更快<br><br>其中线程和进程的区别：<br>1、进程是资源分配的基本单位，线程是程序运行的基本单位<br><br>2、进程有自己的资源空间，线程是共享进程中的数据，所以进程切换开销更大一点<br><br>3、由于线程之间能共享内存地址，因此需要有一些同步和互斥的机制<br><br>4、线程执行开销小，进程执行开销大。<br><br>5、一个线程的意外终止会影响整个进程的正常运行，但是一个进程的意外终止不会影响其他的进程的运行。因此，多进程程序安全性更高。<br></code></pre></td></tr></table></figure>

<h2 id="虚拟地址空间中各个区域存什么数据"><a href="#虚拟地址空间中各个区域存什么数据" class="headerlink" title="虚拟地址空间中各个区域存什么数据"></a>虚拟地址空间中各个区域存什么数据</h2><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs arduino">.text代码段：用来存放代码和常量（<span class="hljs-type">const</span> 关键字定义的变量）<br>.data 数据段：用来存放有初始值的全局变量、全部静态变量。<br>.bss段：用来存放没有初始值的全局变量。<br>栈区：用来存放局部变量，函数的参数，返回值等，由编译器自动分配释放。栈区的地址是从高地址向下增长的。<br>堆区:用来动态内存分配，如 malloc, <span class="hljs-keyword">new</span> 申请的内存，由程序员手动分配释放，堆区使用时地址向上增长。<br></code></pre></td></tr></table></figure>

<h2 id="被free回收的内存是立即返还给操作系统吗"><a href="#被free回收的内存是立即返还给操作系统吗" class="headerlink" title="被free回收的内存是立即返还给操作系统吗"></a>被free回收的内存是立即返还给操作系统吗</h2><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gams">不是的，被<span class="hljs-keyword">free</span>回收的内存会首先被ptmalloc使用双链表保存起来，当用户下一次申请内存的时候，会尝试从这些内存中寻找合适的返回。这样就避免了频繁的系统调用，占用过多的系统资源。同时ptmalloc也会尝试对小块内存进行合并，避免过多的内存碎片。<br></code></pre></td></tr></table></figure>

<h2 id="什么是僵尸进程、孤儿进程、守护进程"><a href="#什么是僵尸进程、孤儿进程、守护进程" class="headerlink" title="什么是僵尸进程、孤儿进程、守护进程"></a>什么是僵尸进程、孤儿进程、守护进程</h2><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs perl">僵尸进程：是一个进程使用<span class="hljs-keyword">fork</span>创建子进程，如果子进程退出，而父进程并没有调用<span class="hljs-keyword">wait</span>或<span class="hljs-keyword">waitpid</span>获取子进程的状态信息，那么子进程的进程描述符仍然保存在系统中。这种进程称之为僵死进程。<br><br>孤儿进程：一个父进程退出，而它的一个或多个子进程还在运行，那么这些子进程将成为孤儿进程。孤儿进程将被init进程（进程号为<span class="hljs-number">1</span>）所收养，并由init进程完成对它们状态收集工作。<br><br>守护进程：是一种运行在后台的特殊进程，它独立与控制终端 ，并周期性地执行某项任务或等待处理某些发生的事件。<br></code></pre></td></tr></table></figure>

<h2 id="僵尸进程有什么好处吗"><a href="#僵尸进程有什么好处吗" class="headerlink" title="僵尸进程有什么好处吗"></a>僵尸进程有什么好处吗</h2><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs scss">僵尸进程通常被认为是一种不良现象，因为它们占用系统资源并可能导致系统性能下降。<br>但是僵尸进程在特定情况下可能会有一些潜在的好处：<br><br>首先就是当一个进程创建子进程并等待子进程终止时，父进程可以通过检查子进程是否为僵尸进程来知道子进程已经结束执行。这种情况下，就相当于僵尸进程提供了一个通知机制，父进程可以通过查看僵尸进程来确认子进程已经结束，而不必依赖于信号或其他机制。<br><br>提供了子进程的退出状态：僵尸进程保存了子进程的退出状态，包括退出码和终止原因。虽然父进程可以通过其他方式获取子进程的退出状态，如通过 wait() 系统调用，但在某些情况下，僵尸进程提供了一个备用的方式来查看子进程的退出状态。<br></code></pre></td></tr></table></figure>

<h2 id="怎么避免僵尸进程"><a href="#怎么避免僵尸进程" class="headerlink" title="怎么避免僵尸进程"></a>怎么避免僵尸进程</h2><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-number">1</span>):通过signal(SIGCHLD, SIG_IGN)通知内核对子进程的结束不关心，由内核回收<br><span class="hljs-number">2</span>):父进程调用<span class="hljs-keyword">wait</span>/<span class="hljs-keyword">waitpid</span>函数等待子进程结束，如果尚无子进程退出<span class="hljs-keyword">wait</span>会导致父进程阻塞。<span class="hljs-keyword">waitpid</span>可以通过传递WNOHANG使父进程不阻塞立即返回。<br><span class="hljs-number">3</span>):也可以利用signal注册信号处理函数，在信号处理函数调用<span class="hljs-keyword">wait</span>/<span class="hljs-keyword">waitpid</span>等待子进程退出。<br></code></pre></td></tr></table></figure>

<h2 id="讲讲中断的流程"><a href="#讲讲中断的流程" class="headerlink" title="讲讲中断的流程"></a>讲讲中断的流程</h2><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs clean">cpu接受中断请求-&gt;保存中断上下文跳转到中断处理过程-&gt;执行中断上半部-&gt;执行中断下半部-&gt;恢复中断上下文。<br></code></pre></td></tr></table></figure>

<h2 id="中断的作用"><a href="#中断的作用" class="headerlink" title="中断的作用"></a>中断的作用</h2><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs x86asm">因为在一些情况下，操作系统会把<span class="hljs-meta">CPU</span>的使用权交给应用程序，而中断是内核夺回<span class="hljs-meta">CPU</span>使用权的唯一途径<br></code></pre></td></tr></table></figure>

<h2 id="中断为什么分为上半部分和下半部分"><a href="#中断为什么分为上半部分和下半部分" class="headerlink" title="中断为什么分为上半部分和下半部分"></a>中断为什么分为上半部分和下半部分</h2><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs">Linux内核将中断分为上半部分和下半部分是为了让中断处理函数快进快出，<br>把中断处理函数中处理过程比较快的部分放到中断上本部分，将那些处理耗时的代码放到中断下半部分，这样中断处理函数就会快如快出，中断上半部分的内容可以不能被其他中断所打断，中断下半部分可以被其他中断所打断，<br></code></pre></td></tr></table></figure>

<h2 id="软中断和硬中断区别-中断的类型"><a href="#软中断和硬中断区别-中断的类型" class="headerlink" title="软中断和硬中断区别(中断的类型)"></a>软中断和硬中断区别(中断的类型)</h2><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs x86asm">硬中断是由外部事件引起的因此具有随机性和突发性；软中断是执行中断指令产生的，因此不是随机的而是由程序安排好的。<br>硬中断的中断响应周期，<span class="hljs-meta">CPU</span>需要发中断回合信号，软中断的中断响应周期，<span class="hljs-meta">CPU</span>不需发中断回合信号。<br>硬中断的中断号是由中断控制器提供的；软中断的中断号由指令直接给出，无需使用中断控制器。<br>硬中断是可屏蔽的，软中断不可屏蔽。<br><br>硬中断的具体例程：<br>硬中断主要包括网卡或者硬盘等硬件带来的中断，表示硬件的状态出现了变化<br>软中断的具体例程：<br>软中断表示执行中断指令产生的，比如处理网卡产生的数据，当网卡接收到一个数据包之后，硬中断只是把数据拷贝到缓存区中，并且要置一个标志位，告诉操作系统有事做，就是软中断了。<br></code></pre></td></tr></table></figure>

<h2 id="你知道i-o的历程嘛，把操作系统进行i-o的历程以及参与的软硬件串起来整个说一下"><a href="#你知道i-o的历程嘛，把操作系统进行i-o的历程以及参与的软硬件串起来整个说一下" class="headerlink" title="你知道i&#x2F;o的历程嘛，把操作系统进行i&#x2F;o的历程以及参与的软硬件串起来整个说一下"></a>你知道i&#x2F;o的历程嘛，把操作系统进行i&#x2F;o的历程以及参与的软硬件串起来整个说一下</h2><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs clean">操作系统I/O历程是一个计算机系统进行输入输出的过程，它涉及到了多个硬件或者软件<br>首先用户可以通过应用程序来和计算机进行交互，利用操作系统提供的应用程序API来发起输入输出请求<br>当操作系统收到应用程序发来的IO请求时，他会去调用设备驱动程序来执行相应的IO操作，设备驱动程序是一个软件，用来与硬件来进行通信。<br>之后设备驱动程序会调用设备控制器，控制具体的硬件来进行输入输出操作。设备控制器是连接在总线上的硬件设备，用来控制具体的外部设备<br><br>应用程序发出IO信号-&gt;设备驱动程序执行相应的IO操作-&gt;设备驱动程序调动设备控制器来控制具体的外部设备<br></code></pre></td></tr></table></figure>

<h2 id="操作系统中堆栈的作用，与数据结构中的堆和栈的区别"><a href="#操作系统中堆栈的作用，与数据结构中的堆和栈的区别" class="headerlink" title="操作系统中堆栈的作用，与数据结构中的堆和栈的区别"></a>操作系统中堆栈的作用，与数据结构中的堆和栈的区别</h2><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs">在数据结构中，堆是一个满足父子结点关系的完全二叉树，而栈是一个非常简单的结构，拥有先入后出的特性<br>在操作系统中堆和栈都是内存空间，不同的是堆是系统按需申请，动态分配的，而栈是程序运行时自动拥有的一小块内存，大小由参数确定<br></code></pre></td></tr></table></figure>

<h2 id="CPU访问内存的步骤"><a href="#CPU访问内存的步骤" class="headerlink" title="CPU访问内存的步骤"></a>CPU访问内存的步骤</h2><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs clean">CPU首先需要确定要访问的内存的地址<br>之后，CPU将内存的地址发送到内存总线，内存总线是CPU和内存之间的物理通道<br>发送到内存总线之后，内存总线将内存发送到内存模块<br>内存模块会根据收到的地址来去选择相应的存储单元，之后就根据具体的指令，判断是将存储单元中的数据读取出来然后利用数据总线传送到CPU中的寄存器或者缓存中，如果是写操作，那么就将数据总线传过来的数据写入到存储单元中去。<br><br>确定内存地址-&gt;将内存地址发送到内存总线中-&gt;内存总线将内存发送到内存模块-&gt;内存模块根据内存地址找到具体的内存单元-&gt;执行具体的内存指令<br></code></pre></td></tr></table></figure>

<h2 id="讲一下进程与线程与协程的区别，以及你对操作系统的理解"><a href="#讲一下进程与线程与协程的区别，以及你对操作系统的理解" class="headerlink" title="讲一下进程与线程与协程的区别，以及你对操作系统的理解"></a>讲一下进程与线程与协程的区别，以及你对操作系统的理解</h2><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs">进程是资源分配的基本单位，它是程序执行时的一个实例，在程序运行时创建。<br><br>线程是程序执行的最小单位，是进程的一个执行流，一个线程由多个线程组成的。<br><br>协程是一种比线程更加轻量级的存在，完全由程序控制，他可以在不同的执行流之间切换，但不涉及操作系统的线程调度和上下文切换，所以会比线程更快<br><br>其中线程和进程的区别：<br>1、进程是资源分配的基本单位，线程是程序运行的基本单位<br><br>2、进程有自己的资源空间，线程是共享进程中的数据，所以进程切换开销更大一点<br><br>3、由于线程之间能共享内存地址，因此需要有一些同步和互斥的机制<br><br>4、线程执行开销小，进程执行开销大。<br><br>5、一个线程的意外终止会影响整个进程的正常运行，但是一个进程的意外终止不会影响其他的进程的运行。因此，多进程程序安全性更高。<br></code></pre></td></tr></table></figure>

<h2 id="线程如何数据交互，进程如何数据交互"><a href="#线程如何数据交互，进程如何数据交互" class="headerlink" title="线程如何数据交互，进程如何数据交互?"></a>线程如何数据交互，进程如何数据交互?</h2><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs gcode">进程间可以通过管道、信号量、消息队列、共享内存、套接字<br>线程间可以通过条件变量，标志位来通信<br>管道、信号量、消息队列、共享内存、套接字<br><br>管道<span class="hljs-comment">(pipe)</span><br>管道这种通讯方式有两种限制，一是半双工的通信，数据只能单向流动，二是只能在具有亲缘关系的进程间使用<br><br>信号量<span class="hljs-comment">(semophore)</span><br>信号量是一个计数器，可以用来控制多个进程对共享资源的访问。它常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源。因此，主要作为进程间以及同一进程内不同线程之间的同步手段。<br><br>消息队列<span class="hljs-comment">(message queue)</span><br>消息队列是由消息组成的链表，存放在内核中并由消息队列标识符标识。<br><br>共享内存<span class="hljs-comment">(shared memory)</span><br><br>共享内存就是映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以<br>访问。共享内存是最快的 IPC 方式，它是针对其他进程间通信方式运行效率低而专门设计的。它往往与<br>其他通信机制，如信号量，配合使用，来实现进程间的同步和通信。<br><br>套接字<span class="hljs-comment">(socket)</span><br><br>套解字也是一种进程间通信机制，与其他通信机制不同的是，它可用于不同机器间的进程通信。<br><br>线程间的通讯方式<br>（<span class="hljs-number">1</span>）通过条件变量进行线程间的通信<br><br>（<span class="hljs-number">2</span>）通过标志位来通知线程间的通信<br><br>（<span class="hljs-number">3</span>）通过std::furture来进行线程间的通信<br></code></pre></td></tr></table></figure>

<h2 id="内存池的实现"><a href="#内存池的实现" class="headerlink" title="内存池的实现"></a>内存池的实现</h2><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">内存池避免了申请了内存之后，忘记释放而导致的内存泄漏和内存不能循环使用问题<br></code></pre></td></tr></table></figure>

<h2 id="内存对齐"><a href="#内存对齐" class="headerlink" title="内存对齐"></a>内存对齐</h2><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">内存对齐是将数据保存到他的自然边界上，这样就能以最少的次数来读取这个数据<br></code></pre></td></tr></table></figure>

<h2 id="死锁是什么，如何避免？如何恢复？如何预防？"><a href="#死锁是什么，如何避免？如何恢复？如何预防？" class="headerlink" title="死锁是什么，如何避免？如何恢复？如何预防？"></a>死锁是什么，如何避免？如何恢复？如何预防？</h2><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs">死锁是一组相互竞争资源的线程因为他们之间得到互相等待导致“永久“阻塞的现象<br><br>死锁的四个条件：<br>互斥，请求和保持，不可剥夺，循环等待<br><br>如何避免？ 银行家算法<br><br>如何恢复？ 可以使用抢占式恢复<br><br>如何预防？破坏死锁的四个条件<br></code></pre></td></tr></table></figure>

<h2 id="服务器高并发的解决方案你知道多少？"><a href="#服务器高并发的解决方案你知道多少？" class="headerlink" title="服务器高并发的解决方案你知道多少？"></a>服务器高并发的解决方案你知道多少？</h2><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-bullet">- </span>应用数据与静态资源分离保存<br>将静态资源（图片，视频，js，css等）单独保存到专门的静态资源服务器中，在客户端访问的时候从静态资源服务器中返回静态资源，从主服务器中返回应用数据。<br><br><span class="hljs-bullet">- </span>客户端缓存 <br>因为效率最高，消耗资源最小的就是纯静态的html页面，所以可以把网站上的页面尽可能用静态的来实现，在页面过期或者有数据更新之后再将页面重新缓存。或者先生成静态页面，然后用ajax异步请求获取动态数据。<br><br><span class="hljs-bullet">- </span>集群和分布式 （集群是所有的服务器都有相同的功能，请求哪台都可以，主要起分流作用）<br><span class="hljs-code">  （分布式是将不同的业务放到不同的服务器中，处理一个请求可能需要使用到多台服务器，起到加快请求处理的速度。）</span><br><span class="hljs-code">  可以使用服务器集群和分布式架构，使得原本属于一个服务器的计算压力分散到多个服务器上。同时加快请求处理的速度。</span><br><br><span class="hljs-bullet">- </span>反向代理 在访问服务器的时候，服务器通过别的服务器获取资源或结果返回给客户端。<br></code></pre></td></tr></table></figure>

<h2 id="多线程了解吗，和单线程的比较，是否存在不如单线程的情况，为什么以及什么情况不如"><a href="#多线程了解吗，和单线程的比较，是否存在不如单线程的情况，为什么以及什么情况不如" class="headerlink" title="多线程了解吗，和单线程的比较，是否存在不如单线程的情况，为什么以及什么情况不如"></a>多线程了解吗，和单线程的比较，是否存在不如单线程的情况，为什么以及什么情况不如</h2><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs">多线程编程是指在一个应用程序中同时运行多个线程来执行不同的任务，从而提高程序的并发性和性能，<br>多线程允许程序在同一时间内执行多个任务，从而提高程序的并发性和性能。<br>多线程可以更好地利用多核处理器，充分利用系统资源，提高整体资源利用率。<br></code></pre></td></tr></table></figure>

<h2 id="内部碎片和外部碎片"><a href="#内部碎片和外部碎片" class="headerlink" title="内部碎片和外部碎片"></a>内部碎片和外部碎片</h2><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs subunit">说白了，内部碎片和外部碎片的区别就在于内存分没分配，如果分配了，但是分配多了，有一块没用到，那么就是内部碎片，如果没分配内存，那么由于有些内存空闲区比较小，难以利用上，因此就会出现外部内存碎片<br><br>内碎片：分配给某些进程的内存区域中有些部分没用上，常见于固定分配方式<br><br>内存总量相同，100M<br><br>固定分配，将100M分割成10块，每块10M，一个程序需要45M，那么需要分配5块，第五块只用了5M，剩下的5M就是内部碎片；<br><br>分段式分配，按需分配，一个程序需要45M，就给分片45MB，剩下的55M供其它程序使用，不存在内部碎片。<br><br>外碎片：内存中某些空闲区因为比较小，而难以利用上，一般出现在内存动态分配方式中<br><br>分段式分配：内存总量相同，100M，比如，内存分配依次5M，15M，50M，25M，程序运行一段时间之后，5M，15M的程序运行完毕，释放内存，其他程序还在运行，再次分配一个10M的内存供其它程序使用，只能从头开始分片，这样，就会存在10M<span class="hljs-string">+5</span>M的外部碎片<br></code></pre></td></tr></table></figure>



<h2 id="操作系统是如何管理虚拟地址与物理地址之间的关系？"><a href="#操作系统是如何管理虚拟地址与物理地址之间的关系？" class="headerlink" title="操作系统是如何管理虚拟地址与物理地址之间的关系？"></a>操作系统是如何管理虚拟地址与物理地址之间的关系？</h2><p>内存分页与分段</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs sql">分段机制下的虚拟地址由两部分组成，段号和段内偏移量。<br><span class="hljs-number">1</span>：内存分段会产生两个问题：<br>	第一个就是外部碎片的问题。<br>	第二个就是内存交换的效率低的问题。<br>外部碎片是指，比如说有<span class="hljs-number">1</span>G的内存，浏览器占了<span class="hljs-number">128</span>M，游戏占了<span class="hljs-number">512</span>M，音乐占了<span class="hljs-number">256</span>M，这时还剩下<span class="hljs-number">128</span>M，当把浏览器关了之后，这时总的内存还剩下<span class="hljs-number">256</span>，但是会存在一种情况是这<span class="hljs-number">256</span>M内存不是连续的，因此如果想要在申请<span class="hljs-number">200</span>M的空间就申请不了，这就是外部内存碎片<br>内存交换是为了解决外部内存碎片的一种机制，具体表现为可以将音乐占用的<span class="hljs-number">256</span>M内存写道硬盘上，再从硬盘上写回内存中，不过写回的位置并不是原来的位置，而是紧挨着<span class="hljs-number">512</span>M内存的位置，这样就避免了内存碎片问题，但是因为硬盘的访问速度要比内存慢太多了，每一次内存交换，都需要把一大段连续的内存数据写到硬盘上。所以，如果内存交换的时候，交换的是一个占内存空间很大的程序，这样整个机器都会显得卡顿。为了解决内存分段的「外部内存碎片和内存交换效率低」的问题，就出现了内存分页<br><span class="hljs-number">2</span>：内存分页<br>内存分页是怎样解决外部内存碎片和内存交换效率低的？<br>外部碎片：因为当采用了分页，页与页之间是紧密排列的，所以不会有外部碎片。<br>交换效率低：如果内存空间不够，操作系统会把其他正在运行的进程中的「最近没被使用」的内存页面给释放掉，也就是暂时写在硬盘上，称为换出（Swap <span class="hljs-keyword">Out</span>）。一旦需要的时候，再加载进来，称为换入（Swap <span class="hljs-keyword">In</span>）。所以，一次性写入磁盘的也只有少数的一个页或者几个页，不会花太多时间，内存交换的效率就相对比较高。<br>分页会产生的问题是如果每个进程都维护一个页表，会造成很多内存浪费在了存储页表中<br><br>因此，最常用的是这两种结合起来使用 <span class="hljs-comment">-----------来了来了他来了 ===段页式！</span><br>段页式（Segmentation <span class="hljs-keyword">with</span> Paging）它结合了分段（Segmentation）和分页（Paging）两种技术的优点，用于实现虚拟内存的管理。在段页式内存管理中，程序的地址空间被划分为多个段（segments）。每个段由多个页（pages）组成，每个页的大小是固定的。在进行内存映射的时候，逻辑地址被划分为段号和段内偏移量，然后通过段表（Segment <span class="hljs-keyword">Table</span>）找到对应段的基址。接着，将段内偏移量划分为页号和页内偏移量，然后通过页表找到对应的物理页号，并将页内偏移量加上物理页的起始地址得到最终的物理地址。<br><br>Linux主要使用的是分页管理，但是也使用到了分段<br></code></pre></td></tr></table></figure>

<h2 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h2><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs x86asm">在单片机中，由于单片机没有操作系统，因此单片机的<span class="hljs-meta">CPU</span>是直接访问物理地址，因此要想在内存中同时运行两个进程是不可能的，因为第一个进程写入之后，第二个会把第一个进程写入的覆盖掉。<br><br>这里存在的问题就是每个进程都访问了物理地址，而操作系统解决这个的方法就是给他们分配一个虚拟地址，让每个进程不能直接访问物理地址，<br><br>这个和linux里面的ioremap不是一个东西，ioremap是用来将物理地址映射为虚拟地址的<br></code></pre></td></tr></table></figure>

<h2 id="虚拟内存的作用："><a href="#虚拟内存的作用：" class="headerlink" title="虚拟内存的作用："></a><strong>虚拟内存的作用：</strong></h2><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">1):虚拟内存可以使得进程对运行内存超过物理内存大小，因为程序运行符合局部性原理，CPU 访问内存会有很明显的重复访问的倾向性，对于那些没有被经常使用到的内存，我们可以把它换出到物理内存之外，比如硬盘上的 swap 区域。</span><br><span class="hljs-section">2):由于每个进程都有自己的页表，所以每个进程的虚拟内存空间就是相互独立的。进程也没有办法访问其他进程的页表，所以这些页表是私有的，这就解决了多进程之间地址冲突的问题。</span><br><span class="hljs-section">3):页表里的页表项中除了物理地址之外，还有一些标记属性的比特，比如控制一个页的读写权限，标记该页是否存在等。在内存访问方面，操作系统提供了更好的安全性。</span><br></code></pre></td></tr></table></figure>

<h2 id="局部性原理你知道吗？主要有哪两大局部性原理？各自是什么？"><a href="#局部性原理你知道吗？主要有哪两大局部性原理？各自是什么？" class="headerlink" title="局部性原理你知道吗？主要有哪两大局部性原理？各自是什么？"></a>局部性原理你知道吗？主要有哪两大局部性原理？各自是什么？</h2><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs gcode">主要分为时间局部性和空间局部性。<br><br>时间局部性:如果执行了程序中的某条指令，那么不久后这条指令很有可能再次执行;如果某个数据被访问过，不久之后该数据很可能再次被访问。<span class="hljs-comment">(因为程序中存在大量的循环)</span> <br>空间局部性:一旦程序访问了某个数据，在不久之后，该数据包括周围的数据也很有可能被访问。<span class="hljs-comment">(因为很多数据在内存中都是连续存放的，并且程序的指令也是顺序地在内存中存放的)</span>正是因为空间局部性原理，LRU才会进行内存预读<br></code></pre></td></tr></table></figure>



<h2 id="使用malloc分配内存"><a href="#使用malloc分配内存" class="headerlink" title="使用malloc分配内存"></a>使用malloc分配内存</h2><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs scss">malloc可以使用两个函数来分配内存：<span class="hljs-built_in">brk</span>()和<span class="hljs-built_in">mmap</span>()，当要分配的内存小于<span class="hljs-number">128</span>KB，则使用<span class="hljs-built_in">brk</span>()来分配内存，当要分配的大于<span class="hljs-number">128</span>KB，使用<span class="hljs-built_in">mmap</span>()<br><br>malloc分配的是虚拟地址，如果分配后的虚拟内存没有被访问的话，虚拟内存是不会映射到物理内存的，这样就不会占用物理内存了。<br>只有在访问已分配的虚拟地址空间的时候，操作系统通过查找页表，发现虚拟内存对应的页没有在物理内存中，就会触发缺页中断，然后操作系统会建立虚拟内存和物理内存之间的映射关系。<br><br>为什么不一直使用mmap？<br>mmap他是一个库函数，因此他会有一个调用的过程，或存在用户态到内核态，再从内核态到用户态的切换过程，并且使用mmap申请的空间在释放之后，会立即返回操作系统，因此，如果频繁通过 mmap 分配的内存话，不仅每次都会发生运行态的切换，还会发生缺页中断（在第一次访问虚拟地址后），这样会导致 CPU 消耗较大，brk是从堆上分配空间，因为堆是连续的，因此可以预分配更大的内存来作为内存池，当内存释放的时候，就放入到内存池中减少了系统调用和缺页中断的次数，加大了CPU的效率<br>为什么不一直使用brk？<br>对于大块内存使用brk的话，会产生内存泄漏问题<br></code></pre></td></tr></table></figure>

<h2 id="内存满了会发生什么？OOM"><a href="#内存满了会发生什么？OOM" class="headerlink" title="内存满了会发生什么？OOM"></a>内存满了会发生什么？OOM</h2><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs ada">当使用malloc函数申请内存的时候，先分配了虚拟内存，然后去访问这个虚拟内存时，发现她没有映射的物理内存，就会切换到内核态去触发缺页中断函数，这时缺页中断处理函数会看是否有空闲的物理内存，如果有，就直接分配物理内存，并建立虚拟内存与物理内存之间的映射关系。<br><br>如果发现内存已经满了，那么内核就会开始内存回收工作，回收工作主要有两种：<br><span class="hljs-number">1</span>：后台内存回收（kswapd）：在物理内存紧张的时候，会唤醒 kswapd 内核线程来回收内存，这个回收内存的过程异步的，不会阻塞进程的执行。<br><span class="hljs-number">2</span>：直接内存回收（direct reclaim）：如果后台异步回收跟不上进程内存申请的速度，就会开始直接回收，这个回收内存的过程是同步的，会阻塞进程的执行。<br><br>如果直接内存回收后，空闲的物理内存仍然无法满足此次物理内存的申请，那么内核就会放最后的大招了 ——触发OOM（<span class="hljs-keyword">Out</span> <span class="hljs-keyword">of</span> Memory）机制。<br><span class="hljs-comment">-----这玩意老狠了，直接把占用大的删了wc------</span><br>OOM Killer机制会根据算法选择一个占用物理内存较高的进程，然后将其杀死，以便释放内存资源，如果物理内存依然不足，OOM Killer 会继续杀死占用物理内存较高的进程，直到释放足够的内存位置。<br>可以使用 oom_score_adj这个校准值来避免被OOM杀死，设置为-<span class="hljs-number">1000</span><br></code></pre></td></tr></table></figure>

<h2 id="那些内存可以被回收"><a href="#那些内存可以被回收" class="headerlink" title="那些内存可以被回收"></a>那些内存可以被回收</h2><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">主要有两类内存可以被回收，而且它们的回收方式也不同。主要是文件页和匿名页<br><br>文件页（File-<span class="hljs-keyword">backed </span>Page）：内核缓存的磁盘数据（<span class="hljs-keyword">Buffer）和内核缓存的文件数据（Cache）（缓存的数据）都叫作文件页。大部分文件页，都可以直接释放内存，以后有需要时，再从磁盘重新读取就可以了。而那些被应用程序修改过，并且暂时还没写入磁盘的数据（也就是脏页），就得先写入磁盘，然后才能进行内存释放。所以，回收干净页的方式是直接释放内存，回收脏页的方式是先写回磁盘后再释放内存。</span><br><span class="hljs-keyword"></span>匿名页（Anonymous Page）：这部分内存没有实际载体，比如堆、栈数据等。并且这部分内存很可能还要再次被访问，所以不能直接释放内存，它们回收的方式是通过 Linux 的 <span class="hljs-keyword">Swap </span>机制，<span class="hljs-keyword">Swap </span>会把不常访问的内存先写到磁盘中，然后释放这些内存，给其他更需要的进程使用。再次访问这些内存时，重新从磁盘读入内存就可以了<br><br>这些回收之后一般都是存在磁盘中，这种具有对换功能的操作系统中，磁盘一般也分为文件区和对换区<br></code></pre></td></tr></table></figure>

<h2 id="在4G物理内存的机器上，申请8G内存会成功吗"><a href="#在4G物理内存的机器上，申请8G内存会成功吗" class="headerlink" title="在4G物理内存的机器上，申请8G内存会成功吗"></a>在4G物理内存的机器上，申请8G内存会成功吗</h2><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs avrasm">这个要分情况讨论：<br><span class="hljs-number">1</span>：在 <span class="hljs-number">32</span> 位操作系统，因为进程理论上最大能申请 <span class="hljs-number">3</span> GB 大小的虚拟内存，所以直接申请 <span class="hljs-number">8</span>G 内存，会申请失败。<br><span class="hljs-number">2</span>：在 <span class="hljs-number">64</span>位 位操作系统，因为进程理论上最大能申请 <span class="hljs-number">128</span> TB 大小的虚拟内存，即使物理内存只有 <span class="hljs-number">4</span>GB，申请 <span class="hljs-number">8</span>G 内存也是没问题(只是申请是肯定没问题的)，因为申请的内存是虚拟内存。如果这块虚拟内存被访问了(被访问了之后要去做物理内存和虚拟内存的映射)，要看系统有没有<span class="hljs-keyword">Swap</span>分区：<br>如果没有 <span class="hljs-keyword">Swap</span> 分区，因为物理空间不够，进程会被操作系统杀掉，原因是 OOM（内存溢出）；<br>如果有 <span class="hljs-keyword">Swap</span> 分区，即使物理内存只有 <span class="hljs-number">4</span>GB，程序也能正常使用 <span class="hljs-number">8</span>GB 的内存，进程可以正常运行(这是因为先<span class="hljs-keyword">swap</span>机制将硬盘来当作物理内存来使用了，因此它可以使用的物理内存很大)<br><br><span class="hljs-keyword">swap</span>机制：<br>当系统的物理内存不够用的时候，就需要将物理内存中的一部分空间释放出来，以供当前运行的程序使用。那些被释放的空间可能来自一些很长时间没有什么操作的程序，这些被释放的空间会被临时保存到磁盘，等到那些程序要运行时，再从磁盘中恢复保存的数据到内存中。<br>这种，将内存数据换出磁盘，又从磁盘中恢复数据到内存的过程，就是<span class="hljs-keyword">Swap</span>机制负责的，<span class="hljs-keyword">Swap</span> 就是把一块磁盘空间或者本地文件，当成内存来使用，它包含换出和换入两个过程：<br><br>换出（<span class="hljs-keyword">Swap</span> <span class="hljs-keyword">Out</span>） ，是把进程暂时不用的内存数据存储到磁盘中，并释放这些数据占用的内存；<br>换入（<span class="hljs-keyword">Swap</span> <span class="hljs-keyword">In</span>），是在进程再次访问这些内存的时候，把它们从磁盘读到内存中来<br></code></pre></td></tr></table></figure>

<h2 id="传统的LRU会导致什么问题？"><a href="#传统的LRU会导致什么问题？" class="headerlink" title="传统的LRU会导致什么问题？"></a>传统的LRU会导致什么问题？</h2><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs scss">预读失效导致缓存命中率下降；<br>缓存污染导致缓存命中率下降；<br><br>什么叫预读机制？<br>比如说，应用程序想要从磁盘中读取文件<span class="hljs-selector-tag">A</span>中<span class="hljs-number">0</span>~<span class="hljs-number">3</span>KB的文件，但是由于磁盘的基本读写单位block等于<span class="hljs-number">4</span>KB，因此，会读取<span class="hljs-number">4</span>KB的数据进入内存，但是由于操作系统由于局部性原理，他认为在当前访问数据周围的数据，在未来很有可能被读取，因此它会将访问数据周围的数据也加载到内存中去，也就是<span class="hljs-selector-attr">[4,8]</span>,<span class="hljs-selector-attr">[8,12]</span>,<span class="hljs-selector-attr">[12,16]</span>，于是额外申请了<span class="hljs-number">3</span>个page，这多出来的<span class="hljs-number">3</span>个page就是预读机制，下次读取这些数据的时候，就不用从磁盘读了，直接从cache中读取就行<br>预读失效？<br>预读失效就是预读出来的这些数据并没有被访问，这样就平白无故的申请了一些数据<br>预读失效会带来什么问题？<br>LRU预读的数据会放到LRU链表的头部，而真正常被访问的数据会被放到LRU链表的末端，这时如果预读失效，那么就会导致后面如果再有数据到来，那么就会将常被访问到的数据移出链表，降低了缓存命中率<br>如何避免预读失效带来的影响<br>中心思想就是让预读出来的数据在cache中存储的时候尽可能少，让真正被访问的数据放到链表的头部，Linux中具体的做法是创建两个链表，一个是活跃链表(active)，一个是不活跃链表(inactive)，真正要读取的数据放入到活跃链表中，预读出来的数据放入到不活跃链表中，如果预读的命中了，那么就将他加入到活跃链表中去，如果活跃链表中的数据长时间没有访问，处于链表末端，当有数据到达时，会被移除到不活跃链表<br><br>缓存污染？：<br>就是说，如果应用程序突然想要从磁盘中读取大量数据，但是读取完成之后，这些数据长时间不再进行访问，这时就会把原来活跃链表中的热点数据移除活跃链表，这样就使得一些垃圾数据占据了活跃链表，造成了缓存污染<br>解决缓存污染？<br>提高进入活跃链表的门槛，在Linux中的提高门槛的方式是，当内存第二次访问的时候，才将内存页从不活跃链表中移动到活跃链表中<br></code></pre></td></tr></table></figure>

<h2 id="抖动是什么？-就类似于乒乓效应，只不过是在内存中的"><a href="#抖动是什么？-就类似于乒乓效应，只不过是在内存中的" class="headerlink" title="抖动是什么？(就类似于乒乓效应，只不过是在内存中的)"></a>抖动是什么？(就类似于乒乓效应，只不过是在内存中的)</h2><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gcode">刚刚换出的页面马上又要换入内存，刚刚换入的页面马上又要换出外存，这种频繁的页面调度行为称为抖动，或颠簸。产生抖动的主要原因是进程频繁访问的页面数目高于可用的物理块数<span class="hljs-comment">(分配给进程的物理块不够)</span><br></code></pre></td></tr></table></figure>

<h2 id="从堆和栈上建立对象那个快？"><a href="#从堆和栈上建立对象那个快？" class="headerlink" title="从堆和栈上建立对象那个快？"></a>从堆和栈上建立对象那个快？</h2><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs llvm">不管从哪方面来说，栈的速度一定都大于堆<br><br>可以从以下两个方面说：<br>- 分配和释放，堆在分配和释放时都要调用函数（<span class="hljs-keyword">malloc</span><span class="hljs-punctuation">,</span><span class="hljs-keyword">free</span>)，比如分配时会到堆空间去寻找足够大小的空间（因为多次分配释放后会造成内存碎片），这些都会花费一定的时间，具体可以看看<span class="hljs-keyword">malloc</span>和<span class="hljs-keyword">free</span>的源代码，函数做了很多额外的工作，而栈却不需要这些。<br>- 访问时间，访问堆的一个具体单元，需要两次访问内存，第一次得取得指针，第二次才是真正的数据，而栈只需访问一次。另外，堆的内容被操作系统交换到外存的概率比栈大，栈一般是不会被交换出去的。<br></code></pre></td></tr></table></figure>

<h2 id="如何实现线程之间的负载均衡："><a href="#如何实现线程之间的负载均衡：" class="headerlink" title="如何实现线程之间的负载均衡："></a>如何实现线程之间的负载均衡：</h2><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs">可以使用分区器，有两种分区器<br>静态分区器：<br>静态分区器是指多个线程共同处理一个数据源时，每个线程可以处理的数据项的个数是相同的，并且当有的线程先一步处理完任务后，不会帮助其他线程去处理任务，而是会空闲下来，这样做的优点是每个线程需要处理的线程在一开始就确定了，不会产生锁的问题，适合数据元素较多的情况<br>动态分区器：<br>动态分区器是指每次向数据项请求并处理完数据之后，会向数据源在此请求数据，类似于能者多劳，适合数据元素较少的情况<br></code></pre></td></tr></table></figure>

<h2 id="互斥锁-自旋锁-读写锁-条件变量"><a href="#互斥锁-自旋锁-读写锁-条件变量" class="headerlink" title="互斥锁 自旋锁 读写锁 条件变量"></a>互斥锁 自旋锁 读写锁 条件变量</h2><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs x86asm">信号量和互斥锁的区别：最主要的区别在于，信号量在条件满足时，它可以让多个线程(进程)同时进行访问<br>首先信号量是一个非负整数变量，它主要用来统计可用资源的个数，当资源足够时，它允许多个线程进行访问<br>而互斥锁是用来进行互斥的，只允许一个访问者来对资源进行访问<br><br><span class="hljs-number">1</span>.互斥锁是一种简单的加锁的方法来控制对共享资源的访问<br><br><span class="hljs-number">2</span>.条件变量用来自动阻塞一个线程，直到某特殊情况发生为止。通常条件变量和互斥锁同时使用。就是当不满足这个条件时，就将这个线程挂起，满足时在将她唤醒<br><br><span class="hljs-number">3</span>.读写锁与互斥锁类似，读写锁也叫共享互斥锁。读写锁可以有<span class="hljs-number">3</span>种状态：读模式下加锁状态、写模式加锁状态、不加锁状态。一次只有一个线程可以占有写模式的读写锁，但是多个线程可以同时占有读模式的读写锁（允许多个线程读但只允许一个线程写）<br><br><span class="hljs-number">4</span>.自旋锁与互斥量功能一样，唯一一点不同的就是其他锁阻塞后休眠让出<span class="hljs-meta">cpu</span>，而自旋锁阻塞后不会让出<span class="hljs-meta">cpu</span>，也就表示这个线程在经过一段时间的休眠之后，会再次去申请这段临界区，如果不能，那么就再次进入休眠，重复这个过程称为自旋，适用于持有锁的线程占有短时间的情况下，因为自旋的过程的消耗小于挂起和唤醒<br></code></pre></td></tr></table></figure>

<h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">死锁（Deadlock）是在并发编程中一种常见的问题，它发生在多个进程或线程相互等待对方持有的资源而无法继续执行的情况。<br><br>死锁通常涉及多个资源和多个进程（或线程），并满足以下四个必要条件：<br><br>互斥条件（Mutual Exclusion）：至少有一个资源必须是独占的，即同一时刻只能被一个进程或线程持有。<br>持有并等待（Hold <span class="hljs-keyword">and </span><span class="hljs-keyword">Wait）：一个进程或线程可以持有一个资源并等待其他进程或线程拥有的资源。</span><br><span class="hljs-keyword"></span>非抢占条件（No Preemption）：资源不能被抢占，即资源只能被持有者显式地释放。<br>循环等待（Circular <span class="hljs-keyword">Wait）：存在一个进程（或线程）的资源等待序列，使得每个进程（或线程）等待下一个进程（或线程）所持有的资源。</span><br><span class="hljs-keyword"></span>死锁的出现会导致程序无法继续执行，进程或线程陷入无限等待的状态，从而造成系统资源的浪费和程序的停滞。<br><br>解决死锁的方法通常包括以下几种：<br>避免死锁：通过设计合理的算法和系统结构来避免发生死锁。例如，使用资源分配图等技术来检测和避免死锁的发生。<br>检测和恢复：实时检测死锁的发生，并采取相应的措施来解除死锁。例如，使用死锁检测算法来识别死锁，然后通过终止部分进程来解除死锁。<br><br>死锁检测：银行家算法，死锁检测器，最简单的超时机制<br><br>预防死锁：通过破坏死锁发生的四个必要条件中的一个或多个来预防死锁。例如，通过实现资源的抢占、按顺序申请资源、以及限制资源的最大占用时间等方法来预防死锁的发生。<br>避免阻塞：尽量减少资源的持有时间，以降低发生死锁的概率。例如，尽量减少代码中的临界区，及时释放资源等。<br></code></pre></td></tr></table></figure>



<h1 id="C-C"><a href="#C-C" class="headerlink" title="C&#x2F;C++:"></a>C&#x2F;C++:</h1><h2 id="C-有什么关键字"><a href="#C-有什么关键字" class="headerlink" title="C++有什么关键字"></a>C++有什么关键字</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">static</span>：<br>	<span class="hljs-type">static</span>修饰符可用于修饰全局变量、局部变量或函数，三种场景下的作用分别为：<br>  <span class="hljs-number">1.</span> 修饰全局变量时：被修饰的变量称为静态全局变量。该全局变量仅在当前文件内可见(相当于限制了全局变量的可见范围，全局变量所有文件都可见)。<br>  <span class="hljs-number">2.</span> 修饰局部变量时：被修饰的变量称为静态局部变量。变量仅初始化一次，而且由于变量是存储在数据段，而非堆或栈上，因此局部变量在离开作用域后不会被销毁，变量值始终有效直至程序结束。<br>  <span class="hljs-number">3.</span> 修饰函数时：被修饰的函数称为静态函数。该函数仅在当前文件内可见。<br>  可以在头文件中定义<span class="hljs-type">static</span>变量，但是包含该头文件的源文件会有命名相同但实际不同的<span class="hljs-type">static</span>变量<br><span class="hljs-keyword">volatile</span>：<br>	当有变量使用<span class="hljs-keyword">volatile</span>关键字声明变量值的时候，那么系统就会从他的内存所在地来读取数据，而不是从寄存器访问，也就是说对声明的变量来说，不再进行优化了，防止编译器优化导致变量值的读写异常<br><span class="hljs-keyword">extern</span>：<br>	当<span class="hljs-keyword">extern</span>声明在变量或者函数之前时，表示这个变量或者函数是在其他文件中声明或者定义的，在这里拿来使用，也就不在这里分配空间<br>	<span class="hljs-keyword">extern</span><span class="hljs-string">&quot;C&quot;</span>:因为在c++中，函数是可以重载的，但是对于c来说，不存在重载这个说法，对于声明了<span class="hljs-keyword">extern</span>的函数来说，表示这个函数使用c的方式编译<br>			  另外使用<span class="hljs-keyword">extern</span><span class="hljs-string">&quot;C&quot;</span>也可以使用c语言库里的函数(包括使用<span class="hljs-keyword">extern</span><span class="hljs-string">&quot;C&quot;</span>包括c语言头文件)<br>malloc/free和<span class="hljs-keyword">new</span>/<span class="hljs-keyword">delete</span>：<br>	共同点：都是从堆上分配空间，并且需要用户手动释放<br>	区别：malloc和free是函数，而<span class="hljs-keyword">new</span>/<span class="hljs-keyword">delete</span>是操作符，并且前者在申请空间时不会初始化，并且需要手动计算空间大小并传递，而后者在申请空间时可以进行初始化，并且不用计算空间大小，后面跟上空间的类型就行，malloc需要进行类型强转。<br><span class="hljs-keyword">union</span>和<span class="hljs-keyword">struct</span>：<br>	<span class="hljs-keyword">union</span>和<span class="hljs-keyword">struct</span>最大的区别在于内存的利用<br>	<span class="hljs-keyword">struct</span>结构体中各个成员拥有自己的内存，各自使用互不干涉<br>	<span class="hljs-keyword">union</span>各成员共用一块内存，并且同一时间只有一个成员能够得到这块内存的使用权，<br></code></pre></td></tr></table></figure>

<h2 id="C-从代码到可执行程序之间经历了什么"><a href="#C-从代码到可执行程序之间经历了什么" class="headerlink" title="C++从代码到可执行程序之间经历了什么"></a>C++从代码到可执行程序之间经历了什么</h2><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs gcode">（<span class="hljs-number">1</span>）预编译<br>主要处理源代码文件中的以“<span class="hljs-attr">#”开头的预编译指令，例如展开宏定义，处理预编译指令</span><br><span class="hljs-attr">（2</span>）编译<br>把预编译之后生成的xxx.i或xxx.ii文件，进行一系列词法分析、语法分析、语义分析及优化后，生成相应的汇编代码文件，生成汇编文件 xxx.s。<br>（<span class="hljs-number">3</span>）汇编<br>将汇编代码转变成机器可以执行的指令，生成目标文件xxx.o<span class="hljs-comment">(Linux下)</span>、xxx.obj<span class="hljs-comment">(Window下)</span><br>（<span class="hljs-number">4</span>）链接<br>将目标文件进行链接，从而形成一个可以执行的程序。链接分为静态链接和动态链接。<br></code></pre></td></tr></table></figure>

<h2 id="C语言有哪些存储类型："><a href="#C语言有哪些存储类型：" class="headerlink" title="C语言有哪些存储类型："></a>C语言有哪些存储类型：</h2><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs scss">auto(自动)，<span class="hljs-built_in">extern</span>(外部)，<span class="hljs-built_in">register</span>(寄存器)，static(静态)<br></code></pre></td></tr></table></figure>

<h2 id="map与set的区别和底层实现："><a href="#map与set的区别和底层实现：" class="headerlink" title="map与set的区别和底层实现："></a>map与set的区别和底层实现：</h2><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-number">1</span>、底层实现都是红黑树，而unordered_map底层是hash表实现的<br><br><span class="hljs-number">2</span>、map是键值对，关键字起到索引作用，值表示与索引相关联的数据，set是关键字的集合并且每个元素只包含一个关键字。<br><br><span class="hljs-number">3</span>、set迭代器是<span class="hljs-type">const</span>不能修改元素值，map允许修改value不能修改key<br><br><span class="hljs-number">4</span>、map支持下标操作，set不支持。<br></code></pre></td></tr></table></figure>

<h2 id="vector和list的区别是什么-数组和链表"><a href="#vector和list的区别是什么-数组和链表" class="headerlink" title="vector和list的区别是什么(数组和链表)"></a>vector和list的区别是什么(数组和链表)</h2><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs lsl"><span class="hljs-number">1</span>、<span class="hljs-type">vector</span>为数组实现，<span class="hljs-type">list</span>为双向链表<br><br><span class="hljs-number">2</span>、<span class="hljs-type">vector</span>支持随机访问，<span class="hljs-type">list</span>不行<br><br><span class="hljs-number">3</span>、<span class="hljs-type">vector</span>顺序储存，<span class="hljs-type">list</span>随机存储<br><br><span class="hljs-number">4</span>、<span class="hljs-type">vector</span>一次性分配内存，不够才二倍扩容，<span class="hljs-type">list</span>一个个分配内存<br><br><span class="hljs-number">5</span>、<span class="hljs-type">vector</span>随机访问性能好，插入删除比较慢(因为数组每次插入和删除都要讲后面的所有数据后移或者前进一位)，<span class="hljs-type">list</span>插入删除快，但是不支持随机访问<br></code></pre></td></tr></table></figure>



<h2 id="指针和引用的区别"><a href="#指针和引用的区别" class="headerlink" title="指针和引用的区别"></a>指针和引用的区别</h2><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs">指针可以为空指针，而引用必须进行初始化；<br>指针可以改变指向，而引用在初始化之后就不能改变；<br>指针时一个变量，存储的是地址，引用只是一个别名<br><br>什么时候使用指针，或者使用引用？<br>一般使用引用是为了避免对一些大类型的容器进行拷贝，因为使用指针传参是将指针的值拷贝过来，因此如果是类对象这种大类型的，就是用引用，如果是数组，那么就使用指针<br></code></pre></td></tr></table></figure>

<h2 id="排序的时间复杂度："><a href="#排序的时间复杂度：" class="headerlink" title="排序的时间复杂度："></a>排序的时间复杂度：</h2><figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs isbl">快速排序的时间复杂度：最坏情况下是<span class="hljs-function"><span class="hljs-title">O</span>(<span class="hljs-variable">n2</span>)，平均情况下是<span class="hljs-title">O</span>(<span class="hljs-variable">nlogn</span>）</span><br><span class="hljs-function">堆排序：<span class="hljs-title">O</span>(<span class="hljs-variable">nlogn</span>）</span><br><span class="hljs-function">归并排序：<span class="hljs-title">O</span>(<span class="hljs-variable">nlogn</span>）</span><br><span class="hljs-function">冒泡<span class="hljs-title">O</span>(<span class="hljs-variable">n2</span>)</span><br>选择<span class="hljs-function"><span class="hljs-title">O</span>(<span class="hljs-variable">n2</span>)</span><br>插入<span class="hljs-function"><span class="hljs-title">O</span>(<span class="hljs-variable">n2</span>)</span><br></code></pre></td></tr></table></figure>

<h2 id="C-中struct和class的区别"><a href="#C-中struct和class的区别" class="headerlink" title="C++中struct和class的区别"></a>C++中struct和class的区别</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp">相同点<br>都用来自定义数据结构，两者都拥有公有和私有部分；<br><span class="hljs-keyword">class</span>完成的工作同样可以使用<span class="hljs-keyword">struct</span>完成；<br><br>不同点<br><span class="hljs-keyword">struct</span>默认是公有的，<span class="hljs-keyword">class</span>则默认是私有的；<br><span class="hljs-keyword">class</span>默认是<span class="hljs-keyword">private</span>继承， 而<span class="hljs-keyword">struct</span>默认是<span class="hljs-keyword">public</span>继承;<br><span class="hljs-keyword">struct</span>一般用于轻量级注重性能的场景中，<span class="hljs-keyword">class</span>一般用于复杂的场景中；<br></code></pre></td></tr></table></figure>

<h2 id="strcpy和memcpy的区别"><a href="#strcpy和memcpy的区别" class="headerlink" title="strcpy和memcpy的区别"></a>strcpy和memcpy的区别</h2><figure class="highlight hsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs hsp"><span class="hljs-number">1</span>、复制的内容不同。strcpy只能复制字符串，而<span class="hljs-keyword">memcpy</span>可以复制任意类型的内容<br><br><span class="hljs-number">2</span>、实现的方法不同。strcpy不需要指定长度，它遇到被复制字符的串结束符<span class="hljs-string">&quot;\0&quot;</span>才结束，所以容易溢出。<span class="hljs-keyword">memcpy</span>则是根据其第<span class="hljs-number">3</span>个参数决定复制的长度。<br></code></pre></td></tr></table></figure>

<h2 id="全局变量和static全局变量的区别"><a href="#全局变量和static全局变量的区别" class="headerlink" title="全局变量和static全局变量的区别"></a>全局变量和static全局变量的区别</h2><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs">相同点：<br>都是静态存储：全局变量本身就是静态存储方式，静态全局变量当然也是静态存储方式。<br><br>不同点：<br>作用域：非静态全局变量的作用域是整个源程序，当一个源程序由多个原文件组成时，非静态的全局变量在各个源文件中都是有效的。静态全局变量则限制了其作用域，即只在定义该变量的源文件内有效。<br></code></pre></td></tr></table></figure>

<h2 id="快速排序和归并排序"><a href="#快速排序和归并排序" class="headerlink" title="快速排序和归并排序"></a>快速排序和归并排序</h2><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs">归并排序和快排的相同点：<br>1，利用分治思想<br>2，具体实现都用递归<br>归并排序和快排的不同点：<br><br>1，先分解再合并：归并排序先递归分解到一个元素，然后单个元素开始合并排序，自下而上的合并排序；<br>2，边分解边排序：快速排序每次都保证参照物左侧的数都小于参照值，右侧的大于参照值；是自上而下的排序；<br>3，归并排序不是原地排序，快速排序是原地排序，<br><br>快速排序什么时候最好，什么时候最差：<br>最好：每次选择的点都能够正好的将序列分为大小接近相等的两部分<br>最差：原序列部分或者已经是有序的了，<br>每次都选择最小或者最大的点当哨位<br></code></pre></td></tr></table></figure>

<h2 id="sort函数内部如何实现"><a href="#sort函数内部如何实现" class="headerlink" title="sort函数内部如何实现"></a>sort函数内部如何实现</h2><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-built_in">sort</span>不仅仅用了快速排序，还结合了插入排序和堆排序。 <br>STL的<span class="hljs-built_in">sort</span>算法，数据量大时采用快排算法。一旦分段后的数据量小于某个门槛（<span class="hljs-number">16</span>），为避免快排的递归调用带来过大的额外负荷，就改用插入排序。如果递归层次过深，还会改用堆排序。<br></code></pre></td></tr></table></figure>

<h2 id="怎么解决递归过深引发的栈溢出问题？"><a href="#怎么解决递归过深引发的栈溢出问题？" class="headerlink" title="怎么解决递归过深引发的栈溢出问题？"></a>怎么解决递归过深引发的栈溢出问题？</h2><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-number">1</span>：限制递归深度，可以将递归深度作为参数传递，达到一定限制后，结束递归<br><span class="hljs-number">2</span>：使用尾递归方法，因为函数调用会形成一个调用帧，而如果在函数<span class="hljs-selector-tag">A</span>中在调用一个函数<span class="hljs-selector-tag">B</span>，那么就会在<span class="hljs-selector-tag">A</span>的调用帧上方在调用一个调用帧，以此类推，而尾递归是指在函数尾部进行递归调用，因为是在尾部，因此函数<span class="hljs-selector-tag">A</span>的内部变量等信息用不到了，这样就不用保存函数<span class="hljs-selector-tag">A</span>的调用帧，只需要将<span class="hljs-selector-tag">B</span>的调用帧替代<span class="hljs-selector-tag">A</span>的就好，<br></code></pre></td></tr></table></figure>

<h2 id="unordered-map-rehash过程"><a href="#unordered-map-rehash过程" class="headerlink" title="unordered_map rehash过程"></a>unordered_map rehash过程</h2><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arduino">一般我们在使用unordered_map函数的时候，不会使用到rehash函数，当map容器已经填满时，unordered_map会自动调用rehash函数来增加容器的大小，同样的我们也可以自己手动的调用rehash函数来增加容器大小，将原来的元素重新映射到新的容器中<br></code></pre></td></tr></table></figure>

<h2 id="c-c-的区别："><a href="#c-c-的区别：" class="headerlink" title="c&#x2F;c++的区别："></a>c&#x2F;c++的区别：</h2><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs llvm">最主要的区别在于<span class="hljs-keyword">c</span>是面向过程的，<span class="hljs-keyword">c</span>++是面向对象的<br>他们的后缀不同，<span class="hljs-keyword">c</span>的后缀是.<span class="hljs-keyword">c</span>，<span class="hljs-keyword">c</span>++的后缀是.cpp<br><span class="hljs-keyword">c</span>不支持函数重载，<span class="hljs-keyword">c</span>++支持函数重载<br></code></pre></td></tr></table></figure>

<h2 id="虚函数和纯虚函数的区别："><a href="#虚函数和纯虚函数的区别：" class="headerlink" title="虚函数和纯虚函数的区别："></a>虚函数和纯虚函数的区别：</h2><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs">虚函数是在基类中定义并实现了的，而纯虚函数是在基类中定义但是并没有实现，具体的实现要在子类中<br>子类继承了父类之后，子类也可以不对虚函数进行重写，但是对于纯虚函数来说，子类继承了父类之后，必须进行重写<br>带纯虚函数的类叫做抽象类，这种类不能直接生成对象，而只有被继承，并重写其虚函数后，才能使用<br></code></pre></td></tr></table></figure>

<h2 id="零拷贝"><a href="#零拷贝" class="headerlink" title="零拷贝"></a>零拷贝</h2><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs scss">零拷贝就是一种避免 CPU 将数据从一块存储拷贝到另外一块存储的技术。<br>这其中也涉及到了<span class="hljs-built_in">emplace_back</span>() <span class="hljs-built_in">push_back</span>()的区别<br>使用<span class="hljs-built_in">push_back</span>()函数需要调用拷贝构造函数，而使用<span class="hljs-built_in">emplace_back</span>()插入的元素原地构造，不需要触发拷贝构造，效率更高。<br></code></pre></td></tr></table></figure>

<h2 id="一个空类会默认添加哪些函数"><a href="#一个空类会默认添加哪些函数" class="headerlink" title="一个空类会默认添加哪些函数"></a>一个空类会默认添加哪些函数</h2><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs oxygene"><span class="hljs-number">1</span>)  <span class="hljs-keyword">Empty</span>()<span class="hljs-punctuation">;</span> <span class="hljs-comment">// 默认构造函数 </span><br><span class="hljs-number">2</span>)  <span class="hljs-keyword">Empty</span>( <span class="hljs-keyword">const</span> <span class="hljs-keyword">Empty</span>&amp; )<span class="hljs-punctuation">;</span> <span class="hljs-comment">// 默认拷贝构造函数 </span><br><span class="hljs-number">3</span>)  ~<span class="hljs-keyword">Empty</span>()<span class="hljs-punctuation">;</span> <span class="hljs-comment">// 析构函数 </span><br><span class="hljs-number">4</span>)  <span class="hljs-keyword">Empty</span>&amp; <span class="hljs-keyword">operator</span>=( <span class="hljs-keyword">const</span> <span class="hljs-keyword">Empty</span>&amp; )<span class="hljs-punctuation">;</span> <span class="hljs-comment">// 默认赋值运算符函数 </span><br></code></pre></td></tr></table></figure>

<h2 id="什么是一致性哈希"><a href="#什么是一致性哈希" class="headerlink" title="什么是一致性哈希"></a>什么是一致性哈希</h2><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs arcade">由于普通哈希算法实现的缓存负载均衡存在扩展能力和容错能力差问题，所以我们引入一致性哈希算法<br><br>一致性哈希：就是普通取模哈希算法的改良版，哈希函数计算方法不变，只不过是通过构建环状的<span class="hljs-built_in">Hash</span>空间代替普通的线性<span class="hljs-built_in">Hash</span>空间，增强了扩展和容错能力<br></code></pre></td></tr></table></figure>

<h2 id="重载和覆盖-重写-的区别"><a href="#重载和覆盖-重写-的区别" class="headerlink" title="重载和覆盖(重写)的区别"></a>重载和覆盖(重写)的区别</h2><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs">重载是水平的，覆盖是垂直的；<br>重载要求函数名相同，参数类型和数目不同，重写指的是在派生类中覆盖基类的同名函数，基类的函数必须是虚函数，参数类型，数量，返回值都相同。<br></code></pre></td></tr></table></figure>



<h2 id="浅拷贝和深拷贝的区别"><a href="#浅拷贝和深拷贝的区别" class="headerlink" title="浅拷贝和深拷贝的区别"></a>浅拷贝和深拷贝的区别</h2><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs">浅拷贝只是拷贝一个指针，并没有新开辟一个地址，拷贝的指针和原来的指针指向同一块地址，如果原来的指针所指向的资源释放了，那么再释放浅拷贝的指针的资源就会出现错误。<br><br>深拷贝不仅拷贝值，还开辟出一块新的空间用来存放新的值，即使原先的对象被析构掉，释放内存了也不会影响到深拷贝得到的值。<br><br>浅拷贝在对象的拷贝创建时存在风险，即被拷贝的对象析构释放资源之后，拷贝对象析构时会再次释放一个已经释放的资源。而深拷贝的结果是两个对象之间没有任何关系，各自成员地址不同。<br></code></pre></td></tr></table></figure>

<h2 id="什么是内存泄露，如何检测与避免"><a href="#什么是内存泄露，如何检测与避免" class="headerlink" title="什么是内存泄露，如何检测与避免"></a>什么是内存泄露，如何检测与避免</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql">C程序中允许使用`malloc`等函数在堆上申请内存，若申请的内存一直未释放或无法释放，最后会导致堆可用的空间越来越少，严重的会导致程序崩溃。常见的内存泄漏原因是申请了内存，但内存不再使用后却不释放，就会导致内存泄漏<br><br>避免：<br><span class="hljs-operator">-</span> 计数法：使用<span class="hljs-keyword">new</span>或者malloc时，让该数<span class="hljs-operator">+</span><span class="hljs-number">1</span>，<span class="hljs-keyword">delete</span>或<span class="hljs-keyword">free</span>时，该数<span class="hljs-number">-1</span>，程序执行完打印这个计数，如果不为<span class="hljs-number">0</span>则表示存在内存泄露<br><span class="hljs-operator">-</span> 有<span class="hljs-keyword">new</span>就有<span class="hljs-keyword">delete</span>，有malloc就有<span class="hljs-keyword">free</span>，保证它们一定成对出现<br><span class="hljs-operator">-</span> 尽量使用智能指针代替普通指针<br><span class="hljs-operator">-</span> 将基类的析构函数声明为虚函数<br></code></pre></td></tr></table></figure>

<h2 id="类成员初始化方式？区别？构造函数的执行顺序-？为什么用成员初始化列表会快一些"><a href="#类成员初始化方式？区别？构造函数的执行顺序-？为什么用成员初始化列表会快一些" class="headerlink" title="类成员初始化方式？区别？构造函数的执行顺序 ？为什么用成员初始化列表会快一些"></a>类成员初始化方式？区别？构造函数的执行顺序 ？为什么用成员初始化列表会快一些</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs markdown">主要是初始化列表方式少调用一次构造函数<br><span class="hljs-bullet">1.</span> 直接在函数体内进行赋值初始化；<br><span class="hljs-bullet">2.</span> 初始化列表进行初始化<br><br>这两种方式的主要区别在于：<br><br>构造函数的执行顺序是成员变量的声明顺序<br><br>对于在函数体中初始化，是在所有的数据成员被分配内存空间后才进行的。<br><br>列表初始化是给数据成员分配内存空间时就进行初始化，初始化这个数据成员此时函数体还未执行，因为用初始化列表会少调用一次构造函数，快一些<br></code></pre></td></tr></table></figure>

<h2 id="总结一下静态绑定和动态绑定的区别："><a href="#总结一下静态绑定和动态绑定的区别：" class="headerlink" title="总结一下静态绑定和动态绑定的区别："></a>总结一下静态绑定和动态绑定的区别：</h2><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-bullet">- </span>阶段：静态绑定发生在编译期，动态绑定发生在运行期；<br><span class="hljs-bullet">- </span>更改：动态绑定的动态类型可以更改，但是静态类型无法更改；<br><span class="hljs-bullet">- </span>情况：在继承体系中只有虚函数使用的是动态绑定，其他的全部是静态绑定；<br><br>这个具体体现就是，当一个基类中的函数不是虚函数时，但是派生类中也有一个同名函数，这样当去声明定义一个派生类时，他具体调用哪个函数由这个对象具体的类型去确定，但是如果派生类继承了一个虚函数，那么就由这个指针指向的类型确定。<br><br>虚函数才具有动态绑定<br></code></pre></td></tr></table></figure>

<h2 id="虚函数表"><a href="#虚函数表" class="headerlink" title="虚函数表"></a>虚函数表</h2><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs mathematica">虚函数表（<span class="hljs-variable">Virtual</span> <span class="hljs-built_in">Function</span> <span class="hljs-built_in">Table</span>，简称 <span class="hljs-variable">vtable</span>）是 <span class="hljs-built_in">C</span><span class="hljs-operator">++</span> 中用于实现多态性的关键机制之一。编译器在发现基类中有虚函数时，会自动为每个含有虚函数的类生成一份虚表，该表是一个一维数组，虚表里保存了虚函数的入口地址<br><br>虚函数表的具体用途包括：<br><br>实现动态绑定（<span class="hljs-built_in">Dynamic</span> <span class="hljs-variable">Binding</span>）： 虚函数表用于在运行时确定对象调用的是哪个版本的虚函数。通过基类指针或引用调用虚函数时，程序会根据对象的实际指向的类型来调用对应的虚函数，而不是根据指针或引用的类型。这样就实现了运行时多态性。<br>支持抽象基类： 抽象基类是指包含纯虚函数的类，纯虚函数没有具体的实现，必须由派生类提供实现。通过在虚函数表中存储指向纯虚函数的指针，使得派生类可以覆盖基类的纯虚函数，从而实现多态性。<br>总之，虚函数表的存在使得 <span class="hljs-built_in">C</span><span class="hljs-operator">++</span> 能够在运行时确定对象的实际类型，并且根据实际类型调用对应的虚函数，从而实现多态性和灵活的对象行为。<br></code></pre></td></tr></table></figure>

<p><strong>虚表指针</strong>：在含有虚函数的类实例化对象时，对象地址的前四个字节存储的指向虚表的指针(每个对象的前四个字节中保存一个虚表指针，这个指针指向对象所属类的虚表)</p>
<h2 id="为什么析构函数一般写成虚函数"><a href="#为什么析构函数一般写成虚函数" class="headerlink" title="为什么析构函数一般写成虚函数"></a>为什么析构函数一般写成虚函数</h2><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gcode">如果基类的析构函数没有声明为虚函数，那么在调用基类指针的析构函数时，不管这个基类指针实际指向的对象是哪个，他只会调用基类指针的析构函数<span class="hljs-comment">(因为是静态绑定)</span>，所以基类的一些派生类对象没有进行析构，这样就会导致内存泄漏，只有将析构函数设置为虚函数，这样当基类指针指向派生类对象时，会先调用派生类的析构函数，之后因为派生类的虚构函数是继承自基类的，所以会自动去调用基类的析构函数，因此当删除基类的指针时，派生类的对象也会完全释放<br></code></pre></td></tr></table></figure>

<h2 id="为什么构造函数不能是虚函数"><a href="#为什么构造函数不能是虚函数" class="headerlink" title="为什么构造函数不能是虚函数"></a>为什么构造函数不能是虚函数</h2><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">虚函数对应一个虚函数表，类中存储一个vptr指向这个vtable。如果构造函数是虚函数，就需要通过vtable调用，可是对象没有初始化就没有vptr，无法找到vtable，所以构造函数不能是虚函数。<br></code></pre></td></tr></table></figure>

<h2 id="c-stl中有没有线程安全的容器"><a href="#c-stl中有没有线程安全的容器" class="headerlink" title="c++ stl中有没有线程安全的容器"></a>c++ stl中有没有线程安全的容器</h2><figure class="highlight brainfuck"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs brainfuck"><span class="hljs-comment">c</span><span class="hljs-literal">++</span><span class="hljs-comment">stl中的容器一般都是线程不安全的，但是可以通过增加互斥锁来达到这样一个目的，但是会导致stl的性能下降</span><br></code></pre></td></tr></table></figure>

<h2 id="用到过那些C-11新特性"><a href="#用到过那些C-11新特性" class="headerlink" title="用到过那些C++11新特性"></a><strong>用到过那些C++11新特性</strong></h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">auto</span>：让编译器在编译的时候就推导出变量的类型；<br><span class="hljs-keyword">decltype</span>：推到表达式的类型；<br>智能指针：智能指针是C++<span class="hljs-number">11</span>库里的一个高级指针类，它能够自动管理动态分配的内存资源，并在适当的时候释放该资源，避免了内存泄漏和野指针等问题，<br></code></pre></td></tr></table></figure>

<h2 id="数据结构栈和队列的区别？一般用在哪些场景，举例，栈和队列经常用的操作"><a href="#数据结构栈和队列的区别？一般用在哪些场景，举例，栈和队列经常用的操作" class="headerlink" title="数据结构栈和队列的区别？一般用在哪些场景，举例，栈和队列经常用的操作"></a>数据结构栈和队列的区别？一般用在哪些场景，举例，栈和队列经常用的操作</h2><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">栈是先入后出，队列是先入先出，<br></code></pre></td></tr></table></figure>

<h2 id="介绍一下-堆-这个数据结构？"><a href="#介绍一下-堆-这个数据结构？" class="headerlink" title="介绍一下 堆 这个数据结构？"></a>介绍一下 堆 这个数据结构？</h2><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">堆是一个满足父子结点条件的完全二叉树，例如大根堆就是根节点是最大值<br></code></pre></td></tr></table></figure>

<h2 id="介绍一下动态规划的思想？上楼梯问题了解吗？用了动态规划和暴力时间复杂度分别是多少？"><a href="#介绍一下动态规划的思想？上楼梯问题了解吗？用了动态规划和暴力时间复杂度分别是多少？" class="headerlink" title="介绍一下动态规划的思想？上楼梯问题了解吗？用了动态规划和暴力时间复杂度分别是多少？"></a>介绍一下动态规划的思想？上楼梯问题了解吗？用了动态规划和暴力时间复杂度分别是多少？</h2><figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs isbl">动态规划的思想类似于“我们要模拟完成一个大任务”，这个大任务可以分成若干个小任务，每个任务有若干种决策，每个任务完成后，就到达了一个阶段性状态，动态规划时间复杂度为<span class="hljs-function"><span class="hljs-title">O</span>(<span class="hljs-variable">n</span>)</span><br></code></pre></td></tr></table></figure>

<h2 id="什么是稳定排序？"><a href="#什么是稳定排序？" class="headerlink" title="什么是稳定排序？"></a>什么是稳定排序？</h2><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs">稳定排序指具有多个相同关键字的序列经过排序之后，这些记录的相对次序不变，则是稳定排序，稳定排序：冒泡排序，基数排序<br>不稳定排序：堆排序，快排<br></code></pre></td></tr></table></figure>

<h2 id="智能指针？三大智能指针内部实现和做什么的"><a href="#智能指针？三大智能指针内部实现和做什么的" class="headerlink" title="智能指针？三大智能指针内部实现和做什么的"></a>智能指针？三大智能指针内部实现和做什么的</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs cpp">智能指针是C++<span class="hljs-number">11</span>库里的一个高级指针类，它能够自动管理动态分配的内存资源，并在适当的时候释放该资源，避免了内存泄漏和野指针等问题，<br><br>常见的智能指针unique_ptr，shared_ptr，weak_ptr<br>shared_ptr通常用于一些资源创建昂贵比较耗时的场景，当需要共享资源的所有权时，例如，一个资源需要被多个对象共享，但是不知道哪个对象会最后释放它，这时候就可以使用std::shared_ptr&lt;T&gt;。<br>unique_ptr“独占”所指向的对象，unique_ptr有更小的内存，而且不需要维护引用计数，因此它的性能更好。当我们需要独占所指向的对象时，应该优先使用std::unique_ptr<br>weak_ptr，weak_ptr一般是通过shared_ptr来创建的，weak_ptr用来指向shared_ptr指向的对象，但是不会增加sheared_ptr的引用计数。只是一个观察者的角色，通过观察shared_ptr来判定资源是否存在<br>weak_ptr持有的引用计数，不是资源的引用计数，而是同一个资源的观察者的计数<br>weak_ptr没有提供常用的指针操作，无法直接访问资源，需要先通过lock方法提升为shared_ptr强智能指针，才能访问资源<br>      <br>shared_ptr实现原理：<br>主要涉及到引用计数和析构函数<br>shared_ptr 通过一个引用计数器来跟踪共享对象的引用次数。每当一个新的 shared_ptr 对象指向某个动态分配的内存资源时，引用计数器就会增加。当 shared_ptr 对象超出作用域、被赋予新值、或者被显式调用 <span class="hljs-built_in">reset</span>() 等函数释放资源时，引用计数器就会减少。当引用计数器减少到零时，表示没有 shared_ptr 对象指向该内存资源，于是释放内存资源并销毁相关的控制块。<br><br>shared_ptr 使用一个控制块来管理引用计数和指向动态内存的指针。主要是用来当没有指针指向动态内存的时候，能够正确的释放动态内存<br><br>shared_ptr 的析构函数被设计为自动释放所管理的内存资源。当 shared_ptr 对象超出其作用域时，析构函数会自动被调用，引用计数减少，当引用计数减为零时，控制块会释放动态内存资源，从而避免内存泄漏。<br><br>unique_ptr实现原理：<br>独占所有权：<br>unique_ptr 通过设计原则来保证对于同一个动态分配的内存资源，同一时间只能有一个 unique_ptr 指向它。这种独占所有权的设计使得 unique_ptr 不需要维护引用计数，从而避免了引用计数的开销。<br>控制块：<br>与 shared_ptr 类似，unique_ptr 也使用一个控制块来管理动态分配的内存资源。控制块通常包含一个指针成员，指向动态分配的内存资源，以及一个析构函数，用于释放内存资源。<br>析构函数：<br>unique_ptr 的析构函数被设计为自动释放所管理的内存资源。当 unique_ptr 对象超出其作用域时，析构函数会自动被调用，从而释放动态内存资源，避免内存泄漏。<br>移动语义：<br>移动语义是指unique_ptr可以将内存的所有权转让给其他的unique_ptr，使得在函数返回值或者容器元素传递时，可以高效的转移所有权，而不用将资源释放了，再将所有权转让。<br><br><br><br>shared_ptr和unique_ptr都有一个控制块，它主要用来管理内存资源的，也就是当没有指针指向它的时候，用来释放内存资源的 <br></code></pre></td></tr></table></figure>

<h2 id="为什么c-11要设计move"><a href="#为什么c-11要设计move" class="headerlink" title="为什么c++11要设计move"></a>为什么c++11要设计move</h2><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">为了减少无意义的拷贝和减少内存资源的申请和释放<br></code></pre></td></tr></table></figure>

<h2 id="如果要你设计一个shared-ptr指针，你会怎么设计-有哪些成员函数、成员变量"><a href="#如果要你设计一个shared-ptr指针，你会怎么设计-有哪些成员函数、成员变量" class="headerlink" title="如果要你设计一个shared_ptr指针，你会怎么设计(有哪些成员函数、成员变量)"></a>如果要你设计一个shared_ptr指针，你会怎么设计(有哪些成员函数、成员变量)</h2><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs scss">这个类设计中，SharedPtr类包含了一个指向被管理资源的指针ptr和一个引用计数的指针refCount。当有新的SharedPtr对象指向相同资源时，它们共享同一个refCount，以便正确地跟踪引用计数。当最后一个SharedPtr对象销毁时，释放被管理资源。<br><br>这个类还提供了拷贝构造函数、析构函数、赋值运算符重载，以及解引用操作符和成员访问操作符，使得其行为类似于原生指针。此外，还提供了<span class="hljs-built_in">use_count</span>()函数用于获取当前引用计数，以及<span class="hljs-built_in">isNull</span>()函数用于检查是否为空指针。<br></code></pre></td></tr></table></figure>

<h2 id="vector扩容机制："><a href="#vector扩容机制：" class="headerlink" title="vector扩容机制："></a>vector扩容机制：</h2><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs arduino">当向vector中插入元素时，如果元素有效个数size与空间容量capacity相等时，vector内部会触发扩容机制<br>vector的扩容会<br><span class="hljs-number">1</span>：拷贝旧元素<br><span class="hljs-number">2</span>：释放旧空间<br><br>因为每次扩容都会拷贝元素并且释放旧空间，因此会产生一系列问题：<br>内存分配和复制：每次扩容都需要分配新的内存并复制旧元素，这是一个耗时的操作。<br>迭代器失效：扩容后，所有指向旧元素的迭代器、指针和引用都会失效。<br>频繁扩容：如果vector每次扩容的空间太小，可能会导致频繁扩容，影响性能。<br><br>为了避免这些问题，可以采取以下措施：<br>预留容量：如果你提前知道需要存储的元素数量，可以使用<span class="hljs-built_in">reserve</span>()方法预先分配足够的内存。<br>减少扩容次数：通过合理选择初始容量或使用<span class="hljs-built_in">reserve</span>()来减少扩容的次数。<br><br>windows使用<span class="hljs-number">1.5</span>倍扩容，linux使用<span class="hljs-number">2</span>倍扩容<br></code></pre></td></tr></table></figure>

<h2 id="函数的调用过程："><a href="#函数的调用过程：" class="headerlink" title="函数的调用过程："></a>函数的调用过程：</h2><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs gcode">当程序执行到一个函数调用语句时，控制流将跳转到被调用函数的起始位置，在函数内部，会创建局部变量来存储参数和在函数内部定义的变量。函数的代码被执行，在函数执行期间，程序可能会调用其他函数。如果函数有返回语句，它将返回一个值。在这种情况下，函数调用表达式可以被替换为返回值。<br>这里面还涉及到函数栈，每当调用函数的时候，都会创建一个函数栈帧<span class="hljs-comment">(调用帧)</span>并推入函数栈的顶部，<br></code></pre></td></tr></table></figure>

<p>多态是靠覆盖来实现的，派生类的对象可以赋值给基类的引用，具体调用那个虚函数是看对象是那个类型</p>
<h2 id="C-为什么使用红黑树"><a href="#C-为什么使用红黑树" class="headerlink" title="C++为什么使用红黑树?"></a>C++为什么使用红黑树?</h2><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs scss">红黑树(红黑树的五个特点)：红黑树，一种二叉查找树(二叉查找树表示树已经排序了，左子树小于根节点，右子树大于)，但在每个结点上增加一个存储位表示结点的颜色，二叉查找树的查找时间为<span class="hljs-built_in">O</span>(lgn)<br>	<span class="hljs-number">1</span>.节点要么为黑色要么为红色<br>	<span class="hljs-number">2</span>.根节点为黑色<br>    <span class="hljs-number">3</span>.叶子节点(Nil空节点)为黑色<br>    <span class="hljs-number">4</span>.红色节点的孩子都为黑色节点<br>    <span class="hljs-number">5</span>.任一节点到叶子节点的路径中黑色节点的数量一致。<br></code></pre></td></tr></table></figure>

<h2 id="讲一下set和unordered-set"><a href="#讲一下set和unordered-set" class="headerlink" title="讲一下set和unordered_set"></a>讲一下set和unordered_set</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp">set的底层是红黑树，unordered_set底层是哈希结构<br>set和unordered_set区别在于unordered_set不能对加入的数据进行自动排序<br>这两者都不能对容器内的元素进行随意更改数值，只能先删除之后再插入进行修改数值<br>set的插入查找删除操作因为底层是红黑树，所以时间复杂度是<span class="hljs-built_in">O</span>(logn)，而unordered_set是常数级别的<span class="hljs-built_in">O</span>(N);<br></code></pre></td></tr></table></figure>

<h2 id="什么时候必须使用初始化列表"><a href="#什么时候必须使用初始化列表" class="headerlink" title="什么时候必须使用初始化列表"></a>什么时候必须使用初始化列表</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-bullet">1.</span> 当初始化一个引用成员变量时；<br><span class="hljs-bullet">2.</span> 初始化一个const成员变量时；<br>初始化列表中的初始化顺序是由类中的成员声明顺序决定的，不是初始化列表中的排列顺序决定的。<br></code></pre></td></tr></table></figure>

<h2 id="C-STL迭代器的原理"><a href="#C-STL迭代器的原理" class="headerlink" title="C++STL迭代器的原理"></a>C++STL迭代器的原理</h2><figure class="highlight brainfuck"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs brainfuck"><span class="hljs-comment">在C</span><span class="hljs-literal">++</span><span class="hljs-comment">中的STL容器中，有些容器（vector）可以通过下标索引的方式访问容器里面的数据，但是大部分的容器不能使用这种方式访问容器中的元素。为了统一不同容器的访问方式，STL为每种容器在实现的时候设计了一个内嵌的iterator类，迭代器的作用就是提供一个遍历容器内部所有元素的接口，因此迭代器的内部必须保存一个与容器相关联的指针，然后重载各种运算操作来方便遍历，例如</span><span class="hljs-literal">++</span><span class="hljs-comment">，——等运算符，</span><br><span class="hljs-comment">这个类似于智能指针，智能指针也是通过封装一个指针然后通过引用计数或者其他方法来达到自动释放内存的功能，智能指针也需要对</span><span class="hljs-literal">-</span>&gt;<span class="hljs-string">,</span><span class="hljs-literal">++</span><span class="hljs-comment">等运算符进行重载</span><br></code></pre></td></tr></table></figure>

<h2 id="什么是内存对齐"><a href="#什么是内存对齐" class="headerlink" title="什么是内存对齐"></a>什么是内存对齐</h2><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">内存对齐是指数据在内存中存储时按照一定规则进行排列，使得数据存储的起始地址符合特定的规定，在内存对齐的概念中，最常见的是按字节对齐。在按字节对齐的情况下，数据的起始地址必须是该数据类型所占内存字节大小的整数倍<br></code></pre></td></tr></table></figure>

<h2 id="map的迭代器失效怎么办"><a href="#map的迭代器失效怎么办" class="headerlink" title="map的迭代器失效怎么办"></a>map的迭代器失效怎么办</h2><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs arcade">删除STL容器vector、<span class="hljs-built_in">map</span>中的元素，容易引起迭代器失效问题。<br>对于vector、deque，他们是序列式容器；当当前元素的iterator被删除后，其后的所有元素的迭代器都会失效，这是因为vector，deque都是连续存储的一段空间，当对其进行<span class="hljs-built_in">erase</span>操作时，其后的每一个元素都会向前移一个位置。迭代器失效时会返回下一个有效的迭代器，it=<span class="hljs-built_in">erase</span>(it)。处理方式见，代码<span class="hljs-number">1</span><span class="hljs-number">-2</span>。<br><br>对于list,set,<span class="hljs-built_in">map</span>，删除时只有被删除节点迭代器失效，处理方式在当前迭代器失效前指向下一个迭代器，即<span class="hljs-built_in">erase</span>(it++)。<br><br>这里主要解释一下<span class="hljs-built_in">erase</span>(it++)的执行过程：这句话分三步走，先把iter传值到<span class="hljs-built_in">erase</span>里面，然后iter自增，然后执行<span class="hljs-built_in">erase</span>,所以iter在失效前已经自增了。<br></code></pre></td></tr></table></figure>



<h1 id="Linux："><a href="#Linux：" class="headerlink" title="Linux："></a>Linux：</h1><h2 id="———–Linux网络编程：—————"><a href="#———–Linux网络编程：—————" class="headerlink" title="———–Linux网络编程：—————-"></a>———–Linux网络编程：—————-</h2><h2 id="Reactor和Proactor"><a href="#Reactor和Proactor" class="headerlink" title="Reactor和Proactor"></a>Reactor和Proactor</h2><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs gcode">Reactor模式：<br>要求主线程只负责监听文件描述符是否有事件发生，有的话就立即将该事件通知工作线程，并将可读可写事件放入请求队列，交给工作线程处理，除此之外，主线程不做任何其他实质性的工作，读写数据，就收新的连接，处理客户请求都在工作线程中完成。<br><br>Proactor模式：<br>Proactor模式将所有I/O操作都交给主线程和内核来进行处理<span class="hljs-comment">(读写)</span>，工作线程仅仅负责业务逻辑<span class="hljs-comment">(处理客户请求)</span><br></code></pre></td></tr></table></figure>

<h2 id="socket编程服务器和客户端建立连接的流程"><a href="#socket编程服务器和客户端建立连接的流程" class="headerlink" title="socket编程服务器和客户端建立连接的流程"></a>socket编程服务器和客户端建立连接的流程</h2><p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20240409142413758.png" srcset="/img/loading.gif" lazyload alt="image-20240409142413758"></p>
<p>UDP:</p>
<p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20240410104647697.png" srcset="/img/loading.gif" lazyload alt="image-20240410104647697"></p>
<h2 id="多进程实现并发服务器"><a href="#多进程实现并发服务器" class="headerlink" title="多进程实现并发服务器"></a>多进程实现并发服务器</h2><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs ada">之前的这些TCP通信代码，只有一个<span class="hljs-keyword">accept</span>()发生阻塞/不阻塞，因此只有一个客户端建立连接<br>要实现TCP通信服务器处理并发的任务，可以使用多进程和多线程<br>实现思路：<br>	利用一个父进程，多个子进程，父进程负责等待并接收客户端的连接，建立连接后，就创建一个子进程用于通信<br></code></pre></td></tr></table></figure>

<h2 id="端口复用及其应用场景"><a href="#端口复用及其应用场景" class="headerlink" title="端口复用及其应用场景"></a>端口复用及其应用场景</h2><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs">在传统的网络编程中，同一时间只能有一个应用程序绑定在一个特定的端口上，如果其他应用程序要使用该端口，则会发生冲突。而端口复用技术允许多个应用程序在同一台主机上共享同一个端口，实现并发监听和处理连接请求，这些连接之后可以分配给不同的线程或者进程，提高服务器性能。<br><br>端口复用在以下情况下特别有用：<br><br>并发服务器：在并发服务器中，多个客户端可以同时连接到服务器的同一端口上，实现高并发处理。通过端口复用，每个连接都可以被分配给不同的处理线程或进程，提高服务器的并发性能。<br></code></pre></td></tr></table></figure>



<h2 id="Linux常见命令："><a href="#Linux常见命令：" class="headerlink" title="Linux常见命令："></a>Linux常见命令：</h2><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli">如何查看一个文件中的所有<span class="hljs-string">.py</span>文件<br><span class="hljs-keyword">ls</span> -A <span class="hljs-params">(目录)</span> *<span class="hljs-string">.py</span><br>查看Linux系统中当前运行的所有进程<br>top命令用来监控Linux的系统状况，能显示各个进程的资源占用状况<br><br>nice调整进程的优先级<br></code></pre></td></tr></table></figure>

<h2 id="linux-有哪些缓存，分别在哪里会被用到，举一个例子即可"><a href="#linux-有哪些缓存，分别在哪里会被用到，举一个例子即可" class="headerlink" title="linux 有哪些缓存，分别在哪里会被用到，举一个例子即可"></a>linux 有哪些缓存，分别在哪里会被用到，举一个例子即可</h2><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">页面缓存（Page <span class="hljs-keyword">Cache）：页面缓存是内核将磁盘上的数据缓存在内存中的一种缓存机制。当应用程序读取文件时，内核会将文件的内容从磁盘读取到内存中，并保留在页面缓存中。这样，如果应用程序再次请求相同的文件，内核可以直接从内存中读取，而不需要再次访问磁盘，从而提高了读取文件的速度。</span><br><span class="hljs-keyword"></span><br>使用示例：假设你有一个程序需要读取一个大型日志文件。第一次读取该文件时，内核会将文件内容缓存在页面缓存中。如果稍后再次读取相同的文件，内核将会从页面缓存中读取，而不会再次访问磁盘，从而提高了读取文件的速度。<br><br>inode 缓存：inode 缓存保存了文件系统中每个文件的元数据信息，如文件的权限、大小、所有者等。这样，在文件系统中进行文件访问时，内核可以首先检查 inode 缓存，如果找到相应的 inode，则可以避免频繁地访问磁盘来获取文件的元数据信息。<br><br>使用示例：当你使用 ls -l 命令列出当前目录下的文件时，内核将会使用 inode 缓存来获取每个文件的元数据信息，从而加快列出文件的速度。<br><br>目录项缓存（<span class="hljs-keyword">Directory </span>Entry <span class="hljs-keyword">Cache）：目录项缓存保存了目录中条目（文件和子目录）的索引信息，以加速对文件系统中目录的访问。当需要查找某个文件或目录时，内核可以首先检查目录项缓存，如果找到相应的条目，则可以避免频繁地访问磁盘来获取目录的索引信息。</span><br><span class="hljs-keyword"></span><br>使用示例：当你在文件系统中执行 cd 命令切换目录时，内核会使用目录项缓存来查找目标目录的索引信息，从而加快目录切换的速度。<br></code></pre></td></tr></table></figure>

<h2 id="fork-的原理，哪里体现了fork分配资源？"><a href="#fork-的原理，哪里体现了fork分配资源？" class="headerlink" title="fork() 的原理，哪里体现了fork分配资源？"></a>fork() 的原理，哪里体现了fork分配资源？</h2><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs perl">调用<span class="hljs-keyword">fork</span>之后，操作系统会为子进程分配新的PCB，用于存储进程的执行状态、上下文信息<br>之后会复制父进程的堆栈，数据段和代码段，并且子进程会继承父进程的文件描述符和信号处理器等资源，<br><br>PCB是指进程控制块，每个进程在操作系统中都有一个户口，而这个户口就是进程控制块，他具体来说是一个task_struct结构体<br></code></pre></td></tr></table></figure>

<h2 id="fork-是把进程从1个变成2个，那么最初的进程是从哪里来的？"><a href="#fork-是把进程从1个变成2个，那么最初的进程是从哪里来的？" class="headerlink" title="fork()是把进程从1个变成2个，那么最初的进程是从哪里来的？"></a>fork()是把进程从1个变成2个，那么最初的进程是从哪里来的？</h2><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs csharp">系统启动时先加载内核，然后通过引导程序启动初始进程<span class="hljs-keyword">init</span>或者叫systemd进程，这个进程是所有进程的祖先<br></code></pre></td></tr></table></figure>

<h2 id="启动进程是用户态还是内核态？"><a href="#启动进程是用户态还是内核态？" class="headerlink" title="启动进程是用户态还是内核态？"></a>启动进程是用户态还是内核态？</h2><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">init进程是由内核直接创建的，但他是运行在用户态的<br>普通进程可以在用户态（<span class="hljs-keyword">User</span> <span class="hljs-title">Mode</span>）和内核态（Kernel Mode）之间切换运行，取决于进程当前执行的代码和正在执行的操作。<br>用户态（<span class="hljs-keyword">User</span> <span class="hljs-title">Mode</span>）：在用户态运行时，进程只能访问受限的资源，如进程的用户空间地址、非特权指令、部分系统调用等。大多数应用程序和用户代码都在用户态运行，例如浏览器、文本编辑器、游戏等。<br><br>内核态（Kernel Mode）：在内核态运行时，进程具有更高的特权级别，可以访问系统的全部资源，包括内存、设备、CPU 寄存器等。内核态运行时，进程可以执行特权指令，并直接访问操作系统的内部数据结构和功能。内核态通常用于执行操作系统内核代码和处理硬件中断等特权操作。<br></code></pre></td></tr></table></figure>

<h2 id="进程是通过fork创建的，linux下线程是怎么创建的"><a href="#进程是通过fork创建的，linux下线程是怎么创建的" class="headerlink" title="进程是通过fork创建的，linux下线程是怎么创建的?"></a>进程是通过fork创建的，linux下线程是怎么创建的?</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">可以利用pthread_create来创建线程<br>要了解并区分内核态和用户态线程<br>用户态线程的创建：用户空间的线程库pthread负责管理，内核实际上是看不见的，可以看见并操作的最小粒度是进程<br>内核态创建线程：系统调用<span class="hljs-built_in">clone</span>，由内核直接负责创建、调度、资源分配<br></code></pre></td></tr></table></figure>

<h2 id="如何查看一个程序的调用堆栈"><a href="#如何查看一个程序的调用堆栈" class="headerlink" title="如何查看一个程序的调用堆栈"></a>如何查看一个程序的调用堆栈</h2><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">可以使用gdb <span class="hljs-keyword">backtrace(gdb </span><span class="hljs-keyword">bt) </span>来查看程序的函数调用堆栈<br><span class="hljs-keyword">jstack命令可以查看堆栈信息</span><br></code></pre></td></tr></table></figure>

<h2 id="gdb用法"><a href="#gdb用法" class="headerlink" title="gdb用法"></a>gdb用法</h2><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs">gdb是一种程序调试工具<br>通过在编译的时候增加-g参数来保留调试参数，之后在使用gdb来启动程序来进行调试，包括设置断点，单步执行等<br></code></pre></td></tr></table></figure>

<h2 id="linux用过什么命令"><a href="#linux用过什么命令" class="headerlink" title="linux用过什么命令"></a>linux用过什么命令</h2><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs vim">gcc编译<br><span class="hljs-keyword">ps</span>查看当前进程<br><span class="hljs-built_in">mkdir</span>创建目录<br>查看当前路径<span class="hljs-keyword">pwd</span><br>linux的命令：<br>insmod加载驱动<br>rmmod卸载驱动<br>makefile<br></code></pre></td></tr></table></figure>

<h2 id="查询网络状态的有什么"><a href="#查询网络状态的有什么" class="headerlink" title="查询网络状态的有什么"></a>查询网络状态的有什么</h2><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs autoit">netstat<br><span class="hljs-built_in">ping</span><br></code></pre></td></tr></table></figure>

<h2 id="查询磁盘空间的命令"><a href="#查询磁盘空间的命令" class="headerlink" title="查询磁盘空间的命令"></a>查询磁盘空间的命令</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">df</span>表示以磁盘分区为单位查看磁盘空间，一般使用<span class="hljs-built_in">df</span> -h将磁盘大小适当显示<br><span class="hljs-built_in">du</span>表示显示当前目录的大小	一般使用<span class="hljs-built_in">du</span> -sh<br></code></pre></td></tr></table></figure>

<h2 id="动态链接库和静态链接库"><a href="#动态链接库和静态链接库" class="headerlink" title="动态链接库和静态链接库"></a>动态链接库和静态链接库</h2><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli">动态链接库和静态链接库的区别主要在于库是否在编译的时候被编译进目标代码中去，<br>动态链接库<span class="hljs-string">.so</span>：并没有被编译进目标代码中，只有在程序执行到相关函数的时候才会去调用该函数库中的函数<span class="hljs-params">(有需要才会调用)</span>，因此动态库的改变升级会比较方便，但是因为没有编译进代码中去，所以在程序运行的过程中，需要外部库的支持<br>静态链接库<span class="hljs-string">.a</span>：在程序编译的时候就将整个函数库编译进目标代码中，程序编译完成后，就不需要外部库的支持了，但是当静态库发生改变的时候，整个程序又要重新编译<br></code></pre></td></tr></table></figure>

<h2 id="Linux中如果出现了CPU满载，如何排查问题？"><a href="#Linux中如果出现了CPU满载，如何排查问题？" class="headerlink" title="Linux中如果出现了CPU满载，如何排查问题？"></a>Linux中如果出现了CPU满载，如何排查问题？</h2><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css">首先使用<span class="hljs-attribute">top</span>命令来查看CPU占比最高的进程<br>然后使用<span class="hljs-attribute">top</span> -H -<span class="hljs-selector-tag">p</span> pid0命令找到消耗资源最多的线程<br>最后在使用jstack来打印堆栈信息<br></code></pre></td></tr></table></figure>

<h2 id="多路复用-为什么多路复用使用epoll"><a href="#多路复用-为什么多路复用使用epoll" class="headerlink" title="多路复用(为什么多路复用使用epoll)"></a>多路复用(为什么多路复用使用epoll)</h2><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs perl">多路复用：<br>多路指的是多个<span class="hljs-keyword">socket</span>网络连接<br>复用指的是使用一个线程去监听多个文件描述符的状态<br>IO多路复用指的是一种机制，一个线程可以监视多个描述符，一旦某个描述符就绪（一般是读就绪或者写就绪），能够通知程序进行相应的读写操作。<br><span class="hljs-keyword">select</span>：<span class="hljs-keyword">select</span>采用轮询的方式来监视文件描述符，当调用<span class="hljs-keyword">select</span>时会将全部监听的 fd 从用户态空间拷贝至内核态空间并线性扫描一遍找出就绪的 fd 再返回到用户态。并且<span class="hljs-keyword">select</span>可监听的文件描述符数量有限<br>而poll对比<span class="hljs-keyword">select</span>只是使用了一个pollfd结构而不是<span class="hljs-keyword">select</span>的fd_set结构，仅仅是解决了<span class="hljs-keyword">select</span>的文件描述符数量限制问题<br><br>IO多路复用就是通过一种机制，一个进程可以监视多个描述符，一旦某个描述符就绪，能够通知程序进行相应的读写操作<br>epoll比<span class="hljs-keyword">select</span>和poll更高效的原因：<br>epoll_create创建epoll的实例在内核区，他不用将数据从用户态拷贝到内核区而是直接对内核进行操作<br><span class="hljs-number">1</span>.epoll 采用红黑树管理文件描述符，红黑树插入和删除的都是时间复杂度 O(logN)，不会随着文件描述符数量增加而改变。而<span class="hljs-keyword">select</span>、poll采用数组或者链表的形式管理文件描述符，那么在遍历文件描述符时，时间复杂度会随着文件描述的增加而增加。<br><br><span class="hljs-number">2</span>.epoll 将文件描述符添加和检测分离，减少了文件描述符拷贝的消耗，<span class="hljs-keyword">select</span>&amp;poll 调用时会将全部监听的 fd 从用户态空间拷贝至内核态空间并线性扫描一遍找出就绪的 fd 再返回到用户态。下次需要监听时，又需要把之前已经传递过的文件描述符再读传递进去，增加了拷贝文件的无效消耗，当文件描述很多时，性能瓶颈更加明显。<br>而epoll只需要使用epoll_ctl添加一次，后续的检查使用epoll_wait，epoll_wait仅仅拷贝已经数据到达的部分，因此减少了文件拷贝的消耗。<br><br>epoll的水平触发和边沿触发<br>水平触发：<br><span class="hljs-keyword">socket</span>接收缓冲区不为空 有数据可读 读事件一直触发<br><span class="hljs-keyword">socket</span>发送缓冲区不满 可以继续写入数据 写事件一直触发<br>边沿触发：<br><span class="hljs-keyword">socket</span>的接收缓冲区状态变化时触发读事件，即空的接收缓冲区刚接收到数据时触发读事件<br><span class="hljs-keyword">socket</span>的发送缓冲区状态变化时触发写事件，即满的缓冲区刚空出空间时触发读事件<br><br>好处：<br>io多路复用的好处是能在单进程/单线程中同时检测多个客户端的事件，并不是用来处理高并发，必须要使用多进程/多进程。<br></code></pre></td></tr></table></figure>

<h2 id="Linux中的ioremap函数"><a href="#Linux中的ioremap函数" class="headerlink" title="Linux中的ioremap函数"></a>Linux中的ioremap函数</h2><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mathematica">一般来说，在系统运行时，外设的<span class="hljs-built_in">I</span><span class="hljs-operator">/</span><span class="hljs-built_in">O</span>内存资源的物理地址是已知的，由硬件的设计决定。但是<span class="hljs-variable">CPU</span>通常并没有为这些已知的外设<span class="hljs-built_in">I</span><span class="hljs-operator">/</span><span class="hljs-built_in">O</span>内存资源的物理地址预定义虚拟地址范围，驱动程序并不能直接通过物理地址访问<span class="hljs-built_in">I</span><span class="hljs-operator">/</span><span class="hljs-built_in">O</span>内存资源，而必须将它们映射到核心虚地址空间内（通过页表），然后才能根据映射所得到的核心虚地址范围，通过访内指令访问这些<span class="hljs-built_in">I</span><span class="hljs-operator">/</span><span class="hljs-built_in">O</span>内存资源，<br>对于有<span class="hljs-variable">MMU</span>的处理器，<span class="hljs-variable">Linux</span>内核启动时会初始化<span class="hljs-variable">MMU</span>，设置内存映射，设置好以后处理器访问的都是虚拟地址，而访问不到物理地址。在<span class="hljs-variable">Linux</span>内核中，有许多与硬件相关的操作需要使用到物理内存地址。然而，在内核态中，直接访问物理内存是非常危险的，容易导致系统崩溃。因此，为了安全地访问物理内存，<span class="hljs-variable">Linux</span>内核提供了<span class="hljs-variable">ioremap</span>函数<br>虚拟空间到物理空间的映射，也叫做地址映射。物理内存和虚拟内存之间的转换，需要用到<span class="hljs-variable">ioremap</span><span class="hljs-punctuation">(</span><span class="hljs-punctuation">)</span>。通过<span class="hljs-variable">ioremap</span><span class="hljs-punctuation">(</span><span class="hljs-punctuation">)</span>函数将物理地址映射为虚拟地址后，内核就能通过<span class="hljs-variable">ioremap</span><span class="hljs-punctuation">(</span><span class="hljs-punctuation">)</span>返回的虚拟地址，以虚拟地址<span class="hljs-operator">-&gt;</span><span class="hljs-variable">mmu</span><span class="hljs-punctuation">(</span>内存管理单元<span class="hljs-punctuation">)</span>的页表映射<span class="hljs-operator">-&gt;</span> 物理地址的形式正确地访问到物理地址了。<br>      <br></code></pre></td></tr></table></figure>

<h1 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL:"></a>MySQL:</h1><h2 id="索引："><a href="#索引：" class="headerlink" title="索引："></a>索引：</h2><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs xl">索引的定义就是帮助存储引擎快速获取数据的一种数据结构，形象的说就是索引是数据的目录。<br><br>索引的分类：B+<span class="hljs-keyword">tree</span>是选取最多的索引类型<br>按「数据结构」分类：B+<span class="hljs-keyword">tree</span>索引、Hash索引、Full-<span class="hljs-keyword">text</span>索引。<br>按「物理存储」分类：聚簇索引（主键索引）、二级索引（辅助索引）。<br>按「字段特性」分类：主键索引、唯一索引、普通索引、前缀索引。<br>按「字段个数」分类：单列索引、联合索引。<br><br></code></pre></td></tr></table></figure>

<h2 id="B-树索引"><a href="#B-树索引" class="headerlink" title="B+树索引"></a>B+树索引</h2><p>对于树的索引来说，树的高度越高，那么通常代表着所需要的IO次数也会增加</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">B</span>+树分为主键索引和二级索引：<br>主键索引：<br>主键索引中叶子节点存放数据，非叶子节点只存放索引，而且每个叶子节点里的数据是按主键顺序存放的。每一层父节点的索引值都会出现在下层子节点的索引值中，因此在叶子节点中，包括了所有的索引值信息，并且每一个叶子节点都有两个指针，分别指向下一个叶子节点(也就是同一层的其他叶子节点)和上一个叶子节点(同上)，形成一个双向链表。<br><br>二级索引：<br>二级索引的<span class="hljs-selector-tag">B</span>+树的叶子节点存放的是主键值，而不是实际数据。在查询过程中会先获取主键值，获取主键之后，再通过主键索引中的 <span class="hljs-selector-tag">B</span>+Tree 树查询到对应的叶子节点，然后获取整行数据。这个过程叫「回表」，也就是说要查两个<span class="hljs-selector-tag">B</span>+树才能查到数据<br><span class="hljs-selector-tag">B</span>+树读取一个结点可以当作是一次IO操作，而<span class="hljs-selector-tag">B</span>+树存储千万级数据的时候只需要<span class="hljs-number">3</span>-<span class="hljs-number">4</span>层就可以满足了，因此效率会比较高<br></code></pre></td></tr></table></figure>

<h2 id="为什么MySQL选择B-树作为索引"><a href="#为什么MySQL选择B-树作为索引" class="headerlink" title="为什么MySQL选择B+树作为索引"></a>为什么MySQL选择B+树作为索引</h2><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css">首先，因为mysql中的数据是存储在磁盘中的，而磁盘的访问是很慢的，因此MySQL要考虑到尽可能减少磁盘的IO操作，所以使用<span class="hljs-selector-tag">B</span>+树来作为索引，<span class="hljs-selector-tag">B</span>+树作为一种多叉树作为索引有以下好处：<br><span class="hljs-number">1</span>：<span class="hljs-selector-tag">B</span>+ 树的非叶子节点不存放实际的记录数据，仅存放索引，因此数据量相同的情况下，相比存储即存索引又存记录的 <span class="hljs-selector-tag">B</span> 树，<span class="hljs-selector-tag">B</span>+树的非叶子节点可以存放更多的索引，因此 <span class="hljs-selector-tag">B</span>+ 树可以比 <span class="hljs-selector-tag">B</span> 树更「矮胖」，查询底层节点的磁盘 <span class="hljs-selector-tag">I</span>/O次数会更少。<br><span class="hljs-number">2</span>：<span class="hljs-selector-tag">B</span>+ 树有大量的冗余节点（所有非叶子节点都是冗余索引），这些冗余索引让 <span class="hljs-selector-tag">B</span>+ 树在插入、删除的效率都更高，比如删除根节点的时候，不会像 <span class="hljs-selector-tag">B</span> 树那样会发生复杂的树的变化；<br><span class="hljs-number">3</span>：<span class="hljs-selector-tag">B</span>+ 树叶子节点之间用链表连接了起来(每个叶子结点有两个指针，分别指向下一个和上一个叶子结点)，有利于范围查询，而 <span class="hljs-selector-tag">B</span> 树要实现范围查询，因此只能通过树的遍历来完成范围查询，这会涉及多个节点的磁盘 <span class="hljs-selector-tag">I</span>/O 操作，范围查询效率不如 <span class="hljs-selector-tag">B</span>+ 树。<br></code></pre></td></tr></table></figure>

<h2 id="聚簇索引-主键索引-和非聚簇索引-二级索引"><a href="#聚簇索引-主键索引-和非聚簇索引-二级索引" class="headerlink" title="聚簇索引(主键索引)和非聚簇索引(二级索引)"></a>聚簇索引(主键索引)和非聚簇索引(二级索引)</h2><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs css">聚簇索引：聚簇索引的 <span class="hljs-selector-tag">B</span>+Tree 的叶子节点存放的是实际数据，所有完整的用户记录都存放在主键索引的 <span class="hljs-selector-tag">B</span>+Tree 的叶子节点里；<br>二级索引：二级索引的 <span class="hljs-selector-tag">B</span>+Tree 的叶子节点存放的是主键值，而不是实际数据。<br></code></pre></td></tr></table></figure>

<h2 id="索引失效有哪些"><a href="#索引失效有哪些" class="headerlink" title="索引失效有哪些"></a>索引失效有哪些</h2><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs gcode"><span class="hljs-number">1</span>：对索引使用左模糊匹配或者左右模糊匹配<span class="hljs-comment">(右模糊匹配不会失效)</span><br><span class="hljs-number">2</span>：对索引进行表达式计算<br><span class="hljs-number">3</span>：对索引使用函数<br><span class="hljs-number">4</span>：对索引隐式类型转换<br></code></pre></td></tr></table></figure>

<p>—————事务———————</p>
<h2 id="事务有哪些特性"><a href="#事务有哪些特性" class="headerlink" title="事务有哪些特性"></a>事务有哪些特性</h2><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs">原子性：事务是最小执行单位，不允许分割。原子性确保操作要么全部完成，要么不起作用。<br><br>一致性：执行事务前后，数据保持一致，例如转账中，无论事务是否成功，两者的总金额不变。<br><br>隔离性：并发访问数据库时，一个用户的事务不被其它事务干扰，各并发事务之间数据库是独立的，每个事务都有一个独立的数据空间<br><br>持久性：事务一旦提交，它对数据库的改变是持久的，即使数据库发生故障也不应该对其有任何影响。<br></code></pre></td></tr></table></figure>

<h2 id="innoDB引擎是通过什么技术来保证事务"><a href="#innoDB引擎是通过什么技术来保证事务" class="headerlink" title="innoDB引擎是通过什么技术来保证事务"></a>innoDB引擎是通过什么技术来保证事务</h2><figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mel">持久性是通过 <span class="hljs-keyword">redo</span> <span class="hljs-keyword">log</span> （重做日志）来保证的；<br>原子性是通过 <span class="hljs-keyword">undo</span> <span class="hljs-keyword">log</span>（回滚日志） 来保证的；<br>隔离性是通过 MVCC（多版本并发控制） 或锁机制来保证的；<br>一致性则是通过持久性+原子性+隔离性来保证；<br></code></pre></td></tr></table></figure>

<h2 id="数据库并行事务会引发什么问题"><a href="#数据库并行事务会引发什么问题" class="headerlink" title="数据库并行事务会引发什么问题"></a>数据库并行事务会引发什么问题</h2><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs css">脏读：脏读就是事务<span class="hljs-selector-tag">A</span>在还没有提交事务时，事务<span class="hljs-selector-tag">B</span>访问了事务<span class="hljs-selector-tag">A</span>修改过的数据，之后如果事务<span class="hljs-selector-tag">A</span>发生了回滚，那么就表示事务<span class="hljs-selector-tag">B</span>发生了脏读<br><br>不可重复读：指的是一个事务在多次读取同一个数据时，出现了前后两次读到的数据不一致的情况，这是因为事务<span class="hljs-selector-tag">B</span>可能对数据进行了修改，并提交了事务，导致发生了不可重复读<br><br>幻读：表示在一个事务内多次查询某个符合查询条件的记录数量时，出现了前后两次的数量不一致的情况，就是第二个事务增加或者删除了一个记录，导致第一个事务发生了幻读<br></code></pre></td></tr></table></figure>

<h2 id="事务的隔离级别有哪些："><a href="#事务的隔离级别有哪些：" class="headerlink" title="事务的隔离级别有哪些："></a>事务的隔离级别有哪些：</h2><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">一共有四个隔离级别：读未提交、读提交、可重复读、串行化<br>读未提交（<span class="hljs-keyword">read</span> <span class="hljs-keyword">uncommitted</span>），指一个事务还没提交时，它做的变更就能被其他事务看到；<br>在这个隔离级别下可能会发生：脏读、不可重复读、幻读<br><br>读提交（<span class="hljs-keyword">read</span> <span class="hljs-keyword">committed</span>），指一个事务提交之后，它做的变更才能被其他事务看到；<br>在这个隔离级别下可能会发生：不可重复读、幻读<br><br>可重复读（<span class="hljs-keyword">repeatable</span> <span class="hljs-keyword">read</span>），指一个事务执行过程中看到的数据，一直跟这个事务启动时看到的数据是一致的，MySQL InnoDB 引擎的默认隔离级别；<br>在这个隔离级别下可能会发生：幻读<br><br>串行化（<span class="hljs-keyword">serializable</span> ）；会对记录加上读写锁，在多个事务对这条记录进行读写操作时，如果发生了读写冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行；<br>这个级别会解决所有因并行事务引发的问题<br><br>MySQL默认使用的可重复读隔离级别，但是他可以在很大程度上避免幻读问题(通过MVCC方式解决)<br></code></pre></td></tr></table></figure>

<h1 id="嵌入式八股"><a href="#嵌入式八股" class="headerlink" title="嵌入式八股"></a>嵌入式八股</h1><h2 id="Linux、Windows与FreeRtos的区别？"><a href="#Linux、Windows与FreeRtos的区别？" class="headerlink" title="Linux、Windows与FreeRtos的区别？"></a>Linux、Windows与FreeRtos的区别？</h2><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs">这是三种不同的操作系统，总的来说，<br>Linux 适用于需要强大功能和定制化的场景，<br>Windows 适用于桌面应用和企业应用，<br>FreeRTOS 适用于嵌入式系统和对实时性要求高的场景。选择哪种操作系统取决于具体的需求和应用场景。<br></code></pre></td></tr></table></figure>

<h2 id="创建Linux驱动编写的流程："><a href="#创建Linux驱动编写的流程：" class="headerlink" title="创建Linux驱动编写的流程："></a>创建Linux驱动编写的流程：</h2><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs">1：创建驱动目录和驱动程序<br>2：创建makefile文件<br>3：最后编译并加载驱动模块<br></code></pre></td></tr></table></figure>

<h2 id="I2C和SPI协议"><a href="#I2C和SPI协议" class="headerlink" title="I2C和SPI协议"></a>I2C和SPI协议</h2><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs scss">I2C（Inter-Integrated Circuit）是一种低速的、半双工、同步的串行通信总线协议，用于在集成电路（IC）之间进行通信。它由两根线组成：串行数据线（SDA）和串行时钟线（SCL）。I2C总线采用主从结构，可以支持多个设备(多个主设备和多个从设备)在同一条总线上进行通信，但是I2C最多可以支持<span class="hljs-number">127</span>个设备挂载设备，其中<span class="hljs-number">1</span>个主机，<span class="hljs-number">126</span>个从机(I2C都是在SCL在高电平的时候进行读取数据线SDA的，当SDA从高电平到低电平表示开始，低变高表示结束)<br><br>SPI是一种高速的，全双工，同步的串行通信总线协议，它由四根线组成：<span class="hljs-built_in">SDI</span>(数据输入)、<span class="hljs-built_in">SDO</span>(数据输出)、<span class="hljs-built_in">SCK</span>(时钟)、<span class="hljs-built_in">CS</span>(片选)，它只支持单个主设备与多个从设备进行通信<br><br>区别：<br><span class="hljs-number">1</span>：I2C只有<span class="hljs-number">2</span>条数据线(一条串行数据线，一条串行时钟线)，SPI有<span class="hljs-number">4</span>条数据线(输入输出线，时钟线，片选线)；<br><span class="hljs-number">2</span>：I2C低速，SPI高速<br><span class="hljs-number">3</span>：I2C有应答响应机制，数据可靠性更高，而SPI没有应答机制<br><span class="hljs-number">4</span>：I2C多个主设备和从设备同时连接，SPI智能一个主设备和多个从设备连接<br></code></pre></td></tr></table></figure>

<h2 id="I2C的通信故障怎么检查？"><a href="#I2C的通信故障怎么检查？" class="headerlink" title="I2C的通信故障怎么检查？"></a>I2C的通信故障怎么检查？</h2><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs">1：首先肯定要先检查设备的电源和连接是否正确<br>2：确保每个设备都有唯一的I2C地址，在总线上有多个相同地址的设备时，可能会出现冲突<br>3：检查软件代码，来查找可能的错误<br></code></pre></td></tr></table></figure>

<h2 id="外部中断触发模式有哪些？请分别描述它们的特点和应用场景"><a href="#外部中断触发模式有哪些？请分别描述它们的特点和应用场景" class="headerlink" title="外部中断触发模式有哪些？请分别描述它们的特点和应用场景"></a>外部中断触发模式有哪些？请分别描述它们的特点和应用场景</h2><p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20240416191232599.png" srcset="/img/loading.gif" lazyload alt="image-20240416191232599"></p>
<h2 id="描述一下嵌入式基于ROM的运行方式和基于RAM的运行方式有什么区别？"><a href="#描述一下嵌入式基于ROM的运行方式和基于RAM的运行方式有什么区别？" class="headerlink" title="描述一下嵌入式基于ROM的运行方式和基于RAM的运行方式有什么区别？"></a>描述一下嵌入式基于ROM的运行方式和基于RAM的运行方式有什么区别？</h2><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs scss">基于<span class="hljs-built_in">ROM</span>(只读存储器)的运行方式是指系统程序存储在只读存储器中，并在系统启动时加载到处理器中运行，系统的数据安全性更高，但是容量较小<br><br>而基于<span class="hljs-built_in">RAM</span>(随机存储器)的运行方式是指将嵌入式系统程序存储在随机存储器中，并在系统启动时从外部存储介质加载到RAM中执行，这种方式对数据更改更加灵活，并且存储容量更大<br></code></pre></td></tr></table></figure>

<h2 id="STM32和51单片机"><a href="#STM32和51单片机" class="headerlink" title="STM32和51单片机"></a>STM32和51单片机</h2><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">1</span>：处理器不同，STM32使用的是ARM <span class="hljs-number">32</span>位处理器，而<span class="hljs-number">51</span>单片机是基于<span class="hljs-number">8051</span>的<span class="hljs-number">8</span>位处理器<br><span class="hljs-attribute">2</span>：存储容量不同：stm32配有更大的闪存和RAM，而<span class="hljs-number">51</span>单片机的存储容量较小<br><span class="hljs-attribute">3</span>：性能：STM32有高性能的<span class="hljs-number">32</span>位架构，而<span class="hljs-number">51</span>单片机由于其<span class="hljs-number">8</span>位架构和有限的处理能力，<span class="hljs-number">51</span>单片机通常用于速度要求不高的简单控制任务。<br></code></pre></td></tr></table></figure>

<h2 id="bootloader"><a href="#bootloader" class="headerlink" title="bootloader"></a>bootloader</h2><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm"><span class="hljs-keyword">Bootloader（引导加载器）是启动计算机或嵌入式系统时执行的第一个程序，</span><br><span class="hljs-keyword"></span>它主要作用是初始化系统硬件、加载操作系统，并将控制权转移到操作系统的启动过程。<br>几种在ARM架构中常用的<span class="hljs-keyword">bootloader：</span><br><span class="hljs-keyword"></span>U-<span class="hljs-keyword">Boot、Das </span>U-<span class="hljs-keyword">Boot、barebox</span><br></code></pre></td></tr></table></figure>

<h2 id="什么是交叉编译？为何要有交叉编译？"><a href="#什么是交叉编译？为何要有交叉编译？" class="headerlink" title="什么是交叉编译？为何要有交叉编译？"></a>什么是交叉编译？为何要有交叉编译？</h2><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs">交叉编译就是指在一个操作系统中生成另一种操作系统使用的可执行文件或者库文件的过程<br>为何要有交叉编译？<br>跨平台开发：有些应用程序或者驱动程序需要在不同的硬件平台运行；<br>资源的限制；在原平台可能资源有限，因此在另一个有充足资源的平台来对代码进行编译，生成目标平台的可执行文件<br></code></pre></td></tr></table></figure>

<h2 id="闪存-flash-memory"><a href="#闪存-flash-memory" class="headerlink" title="闪存(flash memory)"></a>闪存(flash memory)</h2><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stata">Flash <span class="hljs-keyword">Memory</span>是一种非易失性存储器，它可以将数据存储在闪存芯片中，它通常用于存储程序代码，操作系统和其他的非易失性数据。在嵌入式系统中，Flash <span class="hljs-keyword">Memory</span>通常是一个很小的存储芯片，但存储容量往往比RAM大得多。<br></code></pre></td></tr></table></figure>

<h2 id="闪存又分为NAND-FLASH-和-NOR-FLASH-有何区别"><a href="#闪存又分为NAND-FLASH-和-NOR-FLASH-有何区别" class="headerlink" title="闪存又分为NAND FLASH 和 NOR FLASH,有何区别"></a>闪存又分为NAND FLASH 和 NOR FLASH,有何区别</h2><figure class="highlight vhdl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs vhdl">因为闪存内可以存储操作系统和程序代码，因此这两个的区别主要体现在代码执行上<br><span class="hljs-number">2.1</span>、<span class="hljs-keyword">Nand</span>-Flash<br><span class="hljs-keyword">Nand</span>-Flash是闪存中的一种，<span class="hljs-keyword">NAND</span>-Flash 的读取是以一次读取一块的形式来进行的，通常是一次读取 <span class="hljs-number">512</span> 个字节，采用这种技术的Flash比较廉价。因此，<span class="hljs-keyword">Nand</span>-flash存储器有容量较大、改写速度快等优点<br><span class="hljs-number">2.2</span>、<span class="hljs-keyword">Nor</span>-Flash<br><span class="hljs-keyword">Nor</span>-Flash的特点是芯片内执行，这样应用程序可以直接在闪存内运行，不必再把代码读到系统Ram中。<span class="hljs-keyword">Nor</span>-Flash的传输效率很高，但是很低的写入和擦除速度大大影响了它的性能，因此<span class="hljs-keyword">Nor</span>-Flash只能用于特定的场合，比如作为Arm板启动代码的载体。<br>他们的主要区别：<br>类别 读 写 擦除 可靠性 容量 用途 价格<br><span class="hljs-keyword">NOR</span> 快 慢 非常慢 比较高 小 保存代码 高<br><span class="hljs-keyword">NAND</span> 快 快 快 低 大 保存数据 低<br></code></pre></td></tr></table></figure>

<h2 id="中断控制器"><a href="#中断控制器" class="headerlink" title="中断控制器"></a>中断控制器</h2><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs delphi">中断控制器（<span class="hljs-keyword">Interrupt</span> Controller）是一种硬件组件，用于管理和分发系统中的中断信号。它的主要功能是处理来自各种硬件和软件的中断请求，并决定如何对它们进行处理<br></code></pre></td></tr></table></figure>

<h2 id="GPIO的几种模式"><a href="#GPIO的几种模式" class="headerlink" title="GPIO的几种模式"></a>GPIO的几种模式</h2><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs">GPIO（通用输入输出）是嵌入式系统中常用的一种外设，用于实现对外部设备的控制和通信，它具有以下几种模式：<br>输入模式：<br>GPIO被配置为接收外部信号，用于读取外部设备的状态或传感器的数据。<br><br>输出模式：<br>GPIO被配置为向外部设备发送信号，可以通过设置GPIO的状态控制外部设备或执行特定操作。<br><br>上拉模式：<br>GPIO被配置为输入模式，并且在没有外部信号输入时，引脚被连接到高电平（通常是VCC）。<br>这样做可以确保在没有外部信号输入时，引脚保持稳定的高电平状态。<br><br>下拉模式：<br>GPIO被配置为输入模式，并且在没有外部信号输入时，引脚被连接到低电平（通常是地）。<br>这样做可以确保在没有外部信号输入时，引脚保持稳定的低电平状态。<br></code></pre></td></tr></table></figure>

<h2 id="在嵌入式系统开发中，什么是RTOS调度器（Scheduler）？"><a href="#在嵌入式系统开发中，什么是RTOS调度器（Scheduler）？" class="headerlink" title="在嵌入式系统开发中，什么是RTOS调度器（Scheduler）？"></a>在嵌入式系统开发中，什么是RTOS调度器（Scheduler）？</h2><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs arduino">在嵌入式系统开发中，RTOS调度器（<span class="hljs-built_in">Scheduler</span>）是实时操作系统（RTOS）的一个核心组件，负责管理系统中的任务（或线程）并按照一定的调度策略来分配处理器资源，以实现多任务的并发执行，主要具有以下几个功能：<br>任务调度，任务切换，中断处理，资源管理<br></code></pre></td></tr></table></figure>

<h2 id="什么是ARM架构？有什么特点？"><a href="#什么是ARM架构？有什么特点？" class="headerlink" title="什么是ARM架构？有什么特点？"></a>什么是ARM架构？有什么特点？</h2><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs armasm"><span class="hljs-symbol">ARM</span>架构是一种低功耗、高性能以及成本效益高的处理器架构，它具有以下特点：<br>低功耗：<span class="hljs-meta">ARM</span>架构专注于低功耗设计，可延长电池寿命并减少能源消耗。<br><br>性能强：尽管低功耗设计，但是多核处理器的设计使其适应多线程应用。<br><br>灵活性：<span class="hljs-meta">ARM</span>架构是可定制的，可以根据不同的需求进行配置。<br><br>易于集成：<span class="hljs-meta">ARM</span>架构的处理器芯片可以与其他硬件和软件组件轻松集成，使其成为系统设计的理想选择。<br><br>跨平台兼容性：<span class="hljs-meta">ARM</span>架构具有广泛的兼容性，可以在不同的操作系统和平台上运行。<br></code></pre></td></tr></table></figure>

<h2 id="ARM处理器的模式怎么切换"><a href="#ARM处理器的模式怎么切换" class="headerlink" title="ARM处理器的模式怎么切换"></a>ARM处理器的模式怎么切换</h2><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs gcode">ARM处理器一共有七种工作模式：<br>用户模式：用于正常执行程序；<br>快速中断模式：用于高速数据传输；<br>外部中断模式：用于中断处理；<br>管理模式：操作系统使用的保护模式；<br>数据访问中终止模式：当数据或者指令终止时进入该模式，可用于虚拟存储及存储保护；<br>未定义指令中止模式：当未定义的指令执行时进入该模式<br>系统模式：运行具有特权的操作系统任务；<br><br>首先，最常见的一种方式是使用中断来进行切换，例如使用软中断<span class="hljs-comment">(也就是中断指令)</span>可以使处理器从用户模式切换到管理模式，或者硬中断也可以使处理器切换到外部中断模式<br></code></pre></td></tr></table></figure>

<h2 id="ARM架构中的DMA是什么"><a href="#ARM架构中的DMA是什么" class="headerlink" title="ARM架构中的DMA是什么"></a>ARM架构中的DMA是什么</h2><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs x86asm">DMA是指一种数据传输方式，DMA控制器可以直接访问系统内存，然后可以与外设进行数据交换，并且不需要<span class="hljs-meta">CPU</span>的参与，提高了数据传输的效率。<br></code></pre></td></tr></table></figure>

<h2 id="ARM流水线"><a href="#ARM流水线" class="headerlink" title="ARM流水线"></a>ARM流水线</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs markdown">ARM处理器的管道流水线是一种用于提高指令执行效率的技术。它将指令执行过程划分为多个阶段，并在每个阶段引入寄存器，使得多条指令可以同时在不同的阶段执行。这样可以提高处理器的吞吐量，使得指令能够更快地完成执行。<br><br>  流水线中的不同阶段包括：<br><br><span class="hljs-bullet">  1.</span> 取指令（Instruction Fetch）<br><span class="hljs-bullet">  2.</span> 译码（Instruction Decode）<br><span class="hljs-bullet">  3.</span> 执行（Execute）<br><span class="hljs-bullet">  4.</span> 访存（Memory Access）<br><span class="hljs-bullet">  5.</span> 写回（Write Back）<br>  <br><span class="hljs-code">    每个阶段负责不同的任务，并且通过寄存器传递结果到下一个阶段。</span><br><span class="hljs-code"></span><br>通过流水线技术，当一条指令执行进入流水线后，后续的指令可以继续进入流水线的不同阶段，从而实现指令级并行（Instruction-Level Parallelism）。这可以提高处理器的效率，使得多条指令可以在同一时间段内重叠执行。<br></code></pre></td></tr></table></figure>

<h2 id="什么是中断？"><a href="#什么是中断？" class="headerlink" title="什么是中断？"></a>什么是中断？</h2><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs">中断是计算机系统中的一种事件，它打断了正常的程序执行流程，中断可以是来自硬件设备的信号或软件生成的信号，在系统发生某种特定事件时触发。<br>中断的作用是使处理器能够及时响应和处理各种事件，提高系统的实时性和并发处理能力。当系统发生中断时，处理器会立即暂停当前正在执行的任务，并跳转到中断处理程序的入口地址，执行相应的中断处理程序。处理程序完成后，处理器会返回原来的执行状态，继续执行被中断的任务。<br></code></pre></td></tr></table></figure>

<h2 id="波特率是什么？波特率为什么要相同"><a href="#波特率是什么？波特率为什么要相同" class="headerlink" title="波特率是什么？波特率为什么要相同"></a>波特率是什么？波特率为什么要相同</h2><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs excel">波特率（Baud <span class="hljs-built_in">rate</span>）是一种衡量数据传输速率的单位，表示每秒传输的信号变化次数。在串行通信中，波特率决定了数据传输的速率。<br><br>为什么波特率要相同：<br><span class="hljs-number">1</span>：如果发送方和接收方的波特率(数据传输速率)不一致，就会导致问题。例如，如果发送方的波特率较高，而接收方的波特率较低，接收方可能无法及时接收到发送方发送的每个比特，导致数据传输错误。相反，如果接收方的波特率较高，而发送方的波特率较低，接收方就会在没有数据传输的时候出现等待时间。<br><br>因此，为了确保数据能够按正确的速率传输并且保持同步，通信双方需要使用相同的波特率。这样，发送方和接收方可以按照相同的时间间隔传输和接收数据，确保数据的准确性和完整性。<br></code></pre></td></tr></table></figure>

<h2 id="同步通信和异步通信"><a href="#同步通信和异步通信" class="headerlink" title="同步通信和异步通信"></a>同步通信和异步通信</h2><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs">同步通信：<br>在同步通信中，发送方和接收方的时钟是相互关联的，数据的传输和接收是基于一个共同的时钟信号进行同步的。发送方在每个时钟周期内按照时钟的节拍发送数据，接收方也按照同样的时钟节拍接收数据。双方通过时钟信号的同步来保证正确的数据传输。同步通信对时序要求较高，需要在通信双方之间建立稳定的时钟信号。<br><br>异步通信：<br>在异步通信中，发送方和接收方没有共同的时钟信号进行同步。数据的传输和接收不依赖于特定的时钟信号，而是通过特定的起始位和停止位来标识数据的传输开始和结束。每个数据帧都有自己的起始和停止位，这样接收方可以通过检测起始和停止位来识别每个数据帧。异步通信相对较为灵活，但需要额外的控制位来标识起始和停止。<br></code></pre></td></tr></table></figure>



<h1 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h1><p>快速排序：</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">quickSort</span><span class="hljs-params">(<span class="hljs-type">int</span> nums[], <span class="hljs-type">int</span> start, <span class="hljs-type">int</span> end)</span> </span>&#123;<br>    <span class="hljs-comment">//数组有多个元素进行排序</span><br>    <span class="hljs-keyword">if</span> (start &lt; end) &#123;<br>        <span class="hljs-type">int</span> base = nums[start];<span class="hljs-comment">//以要进行排序数组第0个元素为base</span><br>        <span class="hljs-type">int</span> left = start;<span class="hljs-comment">//左指针</span><br>        <span class="hljs-type">int</span> right = end;<span class="hljs-comment">//右指针</span><br>        <span class="hljs-keyword">while</span> (left &lt; right) &#123;<br>            <span class="hljs-comment">//从右向左找，比base大，right--</span><br>            <span class="hljs-keyword">while</span> (left&lt; right &amp;&amp; nums[right] &gt;= base) &#123;<br>                right--;<br>            &#125;<br>            <span class="hljs-comment">//比base小，替换left所在位置的数字</span><br>            nums[left] = nums[right];<br>            <span class="hljs-comment">//从左向右找，比base小，left++</span><br>            <span class="hljs-keyword">while</span> (left &lt; right &amp;&amp; nums[left] &lt;= base)&#123;<br>                left++;<br>            &#125;<br>            <span class="hljs-comment">//比base大，替换right所在位置的数字</span><br>            nums[right] = nums[left];<br>        &#125;<br>        nums[left] = base;<span class="hljs-comment">//此时left=right，用base替换这个位置的数字</span><br>        <span class="hljs-comment">//排列比base小的数字的数组</span><br>        <span class="hljs-built_in">quickSort</span>(nums, start, left - <span class="hljs-number">1</span>);<br>        <span class="hljs-comment">//排列比base大的数字的数组</span><br>        <span class="hljs-built_in">quickSort</span>(nums, left + <span class="hljs-number">1</span>, end);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>归并排序：</p>
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">template</span>&lt;typename T&gt;<br><span class="hljs-type">void</span> merge_sort_recursive(T arr[], T reg[], <span class="hljs-type">int</span> <span class="hljs-keyword">start</span>, <span class="hljs-type">int</span> <span class="hljs-keyword">end</span>) &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">start</span> &gt;= <span class="hljs-keyword">end</span>)<br>        <span class="hljs-keyword">return</span>;<br>    <span class="hljs-type">int</span> len = <span class="hljs-keyword">end</span> - <span class="hljs-keyword">start</span>, mid = (len &gt;&gt; <span class="hljs-number">1</span>) + <span class="hljs-keyword">start</span>;<br>    <span class="hljs-type">int</span> start1 = <span class="hljs-keyword">start</span>, end1 = mid;<br>    <span class="hljs-type">int</span> start2 = mid + <span class="hljs-number">1</span>, end2 = <span class="hljs-keyword">end</span>;<br>    merge_sort_recursive(arr, reg, start1, end1);<br>    merge_sort_recursive(arr, reg, start2, end2);<br>    <span class="hljs-type">int</span> k = <span class="hljs-keyword">start</span>;<br>    <span class="hljs-keyword">while</span> (start1 &lt;= end1 &amp;&amp; start2 &lt;= end2)<br>        reg[k++] = arr[start1] &lt; arr[start2] ? arr[start1++] : arr[start2++];<br>    <span class="hljs-keyword">while</span> (start1 &lt;= end1)<br>        reg[k++] = arr[start1++];<br>    <span class="hljs-keyword">while</span> (start2 &lt;= end2)<br>        reg[k++] = arr[start2++];<br>    <span class="hljs-keyword">for</span> (k = <span class="hljs-keyword">start</span>; k &lt;= <span class="hljs-keyword">end</span>; k++)<br>        arr[k] = reg[k];<br>&#125;<br><br>// merge_sort<br><span class="hljs-keyword">template</span>&lt;typename T&gt;<br><span class="hljs-type">void</span> merge_sort(T arr[], const <span class="hljs-type">int</span> len) &#123;<br>    T reg[len];<br>    merge_sort_recursive(arr, reg, <span class="hljs-number">0</span>, len - <span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>堆排序：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> n;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">downAdjust</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; v,<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r)</span> </span>&#123;<br>	<span class="hljs-type">int</span> i = l, j = <span class="hljs-number">2</span>*l;<br>	<span class="hljs-keyword">while</span>(j&lt;=r) &#123;<br>		<span class="hljs-keyword">if</span>(j+<span class="hljs-number">1</span>&lt;=r&amp;&amp;v[j+<span class="hljs-number">1</span>] &lt; v[j])j++<br>		<span class="hljs-keyword">if</span>(v[j] &lt; v[i]) &#123;<br>			<span class="hljs-built_in">swap</span>(v[i],v[j]);<br>			i=j;<br>			j=i*<span class="hljs-number">2</span>;<br>		&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">break</span>;<br>	&#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">create</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; v)</span> </span>&#123;<br>	v.<span class="hljs-built_in">resize</span>(n+<span class="hljs-number">1</span>);<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = n<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">0</span>;--i) v[i+<span class="hljs-number">1</span>] = v[i];<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = n/<span class="hljs-number">2</span>;i&gt;=<span class="hljs-number">1</span>;--i) <span class="hljs-built_in">downAdjust</span>(v,i,n);<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">heapSort</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; v)</span> </span>&#123;<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = n ;i &gt;= <span class="hljs-number">1</span>; --i) &#123;<br>		cout &lt;&lt; v[i] &lt;&lt;<span class="hljs-string">&quot;&quot;</span>;<br>		<span class="hljs-built_in">swap</span>(v[i],v[<span class="hljs-number">1</span>]);<br>		<span class="hljs-built_in">downAdjust</span>(v,<span class="hljs-number">1</span>,i<span class="hljs-number">-1</span>);<br>	&#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>	vector&lt;<span class="hljs-type">int</span>&gt; v&#123;<span class="hljs-number">1</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">8</span>,<span class="hljs-number">7</span>,<span class="hljs-number">3</span>&#125;;<br>	n = v.<span class="hljs-built_in">size</span>();<br>	<span class="hljs-built_in">create</span>(v);<br>	<span class="hljs-built_in">heapsort</span>(v);<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>反转链表：</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-comment">#include &lt;iostream&gt;</span><br><span class="hljs-comment">#include &lt;algorithm&gt;</span><br><br>using namespace std;<br><br>const <span class="hljs-keyword">int</span> N = <span class="hljs-number">1</span>e6 + <span class="hljs-number">10</span>;<br><br><span class="hljs-keyword">int</span> n, k, h, idx;<br><span class="hljs-keyword">int</span> <span class="hljs-keyword">link</span>[N], <span class="hljs-keyword">ne</span>[N], e[N];<br><br><span class="hljs-keyword">int</span> main()<br>&#123;<br>    cin &gt;&gt; h &gt;&gt; n &gt;&gt; k;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i ++ )<br>    &#123;<br>        <span class="hljs-keyword">int</span> ad, val, <span class="hljs-keyword">next</span>;<br>        cin &gt;&gt; ad &gt;&gt; val &gt;&gt; <span class="hljs-keyword">next</span>;<br>        e[ad] = val, <span class="hljs-keyword">ne</span>[ad] = <span class="hljs-keyword">next</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">while</span>(h != -<span class="hljs-number">1</span>)<br>    &#123;<br>        <span class="hljs-keyword">link</span>[idx ++] = h;<br>        h = <span class="hljs-keyword">ne</span>[h];<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i + k &lt;= idx; i += k) <span class="hljs-keyword">reverse</span>(<span class="hljs-keyword">link</span> + i, <span class="hljs-keyword">link</span> + i + k);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; idx; i ++ )<br>    &#123;<br>        <span class="hljs-keyword">if</span>(i + <span class="hljs-number">1</span> &gt;= idx) <span class="hljs-keyword">printf</span>(<span class="hljs-string">&quot;%05d %d -1\n&quot;</span>, <span class="hljs-keyword">link</span>[i], e[<span class="hljs-keyword">link</span>[i]]);<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">printf</span>(<span class="hljs-string">&quot;%05d %d %05d\n&quot;</span>, <span class="hljs-keyword">link</span>[i], e[<span class="hljs-keyword">link</span>[i]], <span class="hljs-keyword">link</span>[i + <span class="hljs-number">1</span>]);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>LFU:</p>
<figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs processing">struct Node &#123;<br>    <span class="hljs-type">int</span> cnt, time, <span class="hljs-built_in">key</span>, value;<br>    <span class="hljs-title function_">Node</span>(<span class="hljs-type">int</span> _cnt, <span class="hljs-type">int</span> _time, <span class="hljs-type">int</span> _key, <span class="hljs-type">int</span> _value):<span class="hljs-title function_">cnt</span>(_cnt), <span class="hljs-title function_">time</span>(_time), <span class="hljs-built_in">key</span>(_key), <span class="hljs-title function_">value</span>(_value)&#123;&#125;<br>    bool operator &lt; (<span class="hljs-keyword">const</span> Node&amp; rhs) <span class="hljs-keyword">const</span> &#123;<br>        <span class="hljs-keyword">return</span> cnt == rhs.<span class="hljs-property">cnt</span> ? time &lt; rhs.<span class="hljs-property">time</span> : cnt &lt; rhs.<span class="hljs-property">cnt</span>;<br>    &#125;<br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">LFUCache</span> &#123;<br>    <span class="hljs-comment">// 缓存容量，时间戳</span><br>    <span class="hljs-type">int</span> capacity, time;<br>    unordered_map&lt;<span class="hljs-type">int</span>, Node&gt; key_table;<br>    <span class="hljs-built_in">set</span>&lt;Node&gt; S;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-title function_">LFUCache</span>(<span class="hljs-type">int</span> _capacity) &#123;<br>        capacity = _capacity;<br>        time = <span class="hljs-number">0</span>;<br>        key_table.<span class="hljs-property">clear</span>();<br>        S.<span class="hljs-property">clear</span>();<br>    &#125;<br>    <br>    <span class="hljs-type">int</span> <span class="hljs-built_in">get</span>(<span class="hljs-type">int</span> <span class="hljs-built_in">key</span>) &#123;<br>        <span class="hljs-keyword">if</span> (capacity == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>        auto it = key_table.<span class="hljs-property">find</span>(<span class="hljs-built_in">key</span>);<br>        <span class="hljs-comment">// 如果哈希表中没有键 key，返回 -1</span><br>        <span class="hljs-keyword">if</span> (it == key_table.<span class="hljs-property">end</span>()) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>        <span class="hljs-comment">// 从哈希表中得到旧的缓存</span><br>        Node cache = it -&gt; <span class="hljs-built_in">second</span>;<br>        <span class="hljs-comment">// 从平衡二叉树中删除旧的缓存</span><br>        S.<span class="hljs-property">erase</span>(cache);<br>        <span class="hljs-comment">// 将旧缓存更新</span><br>        cache.<span class="hljs-property">cnt</span> += <span class="hljs-number">1</span>;<br>        cache.<span class="hljs-property">time</span> = ++time;<br>        <span class="hljs-comment">// 将新缓存重新放入哈希表和平衡二叉树中</span><br>        S.<span class="hljs-property">insert</span>(cache);<br>        it -&gt; <span class="hljs-built_in">second</span> = cache;<br>        <span class="hljs-keyword">return</span> cache.<span class="hljs-property">value</span>;<br>    &#125;<br>    <br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">put</span>(<span class="hljs-type">int</span> <span class="hljs-built_in">key</span>, <span class="hljs-type">int</span> value) &#123;<br>        <span class="hljs-keyword">if</span> (capacity == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span>;<br>        auto it = key_table.<span class="hljs-property">find</span>(<span class="hljs-built_in">key</span>);<br>        <span class="hljs-keyword">if</span> (it == key_table.<span class="hljs-property">end</span>()) &#123;<br>            <span class="hljs-comment">// 如果到达缓存容量上限</span><br>            <span class="hljs-keyword">if</span> (key_table.<span class="hljs-property">size</span>() == capacity) &#123;<br>                <span class="hljs-comment">// 从哈希表和平衡二叉树中删除最近最少使用的缓存</span><br>                key_table.<span class="hljs-property">erase</span>(S.<span class="hljs-property">begin</span>() -&gt; <span class="hljs-built_in">key</span>);<br>                S.<span class="hljs-property">erase</span>(S.<span class="hljs-property">begin</span>());<br>            &#125;<br>            <span class="hljs-comment">// 创建新的缓存</span><br>            Node cache = <span class="hljs-title function_">Node</span>(<span class="hljs-number">1</span>, ++time, <span class="hljs-built_in">key</span>, value);<br>            <span class="hljs-comment">// 将新缓存放入哈希表和平衡二叉树中</span><br>            key_table.<span class="hljs-property">insert</span>(<span class="hljs-title function_">make_pair</span>(<span class="hljs-built_in">key</span>, cache));<br>            S.<span class="hljs-property">insert</span>(cache);<br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// 这里和 get() 函数类似</span><br>            Node cache = it -&gt; <span class="hljs-built_in">second</span>;<br>            S.<span class="hljs-property">erase</span>(cache);<br>            cache.<span class="hljs-property">cnt</span> += <span class="hljs-number">1</span>;<br>            cache.<span class="hljs-property">time</span> = ++time;<br>            cache.<span class="hljs-property">value</span> = value;<br>            S.<span class="hljs-property">insert</span>(cache);<br>            it -&gt; <span class="hljs-built_in">second</span> = cache;<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>LRU</p>
<figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">struct DLinkedNode &#123;<br>    int key, value;<br>    DLinkedNode* prev;<br>    DLinkedNode* next;<br>    DLinkedNode(): key(<span class="hljs-number">0</span>), value(<span class="hljs-number">0</span>), prev(nullptr), next(nullptr) &#123;&#125;<br>    DLinkedNode(int _key, int _value): key(_key), value(_value), prev(nullptr), next(nullptr) &#123;&#125;<br>&#125;;<br><br>class LRUCache &#123;<br>private:<br>    unordered_map<span class="hljs-tag">&lt;int, DLinkedNode*&gt;</span> cache;<br>    DLinkedNode* head;<br>    DLinkedNode* tail;<br>    int size;<br>    int capacity;<br><br>public:<br>    LRUCache(int _capacity): capacity(_capacity), size(<span class="hljs-number">0</span>) &#123;<br>        // 使用伪头部和伪尾部节点<br>        head = new DLinkedNode();<br>        tail = new DLinkedNode();<br>        head-&gt;next = tail;<br>        tail-&gt;prev = head;<br>    &#125;<br>    <br>    int get(int key) &#123;<br>        if (!cache.count(key)) &#123;<br>            return -<span class="hljs-number">1</span>;<br>        &#125;<br>        // 如果 key 存在，先通过哈希表定位，再移到头部<br>        DLinkedNode* <span class="hljs-keyword">node</span> <span class="hljs-title">= cache</span>[key];<br>        moveToHead(<span class="hljs-keyword">node</span><span class="hljs-title">);</span><br><span class="hljs-title">        return</span> <span class="hljs-keyword">node</span><span class="hljs-title">-&gt;value</span>;<br>    &#125;<br>    <br>    void put(int key, int value) &#123;<br>        if (!cache.count(key)) &#123;<br>            // 如果 key 不存在，创建一个新的节点<br>            DLinkedNode* <span class="hljs-keyword">node</span> <span class="hljs-title">= new</span> DLinkedNode(key, value);<br>            // 添加进哈希表<br>            cache[key] = <span class="hljs-keyword">node</span><span class="hljs-title">;</span><br><span class="hljs-title">            // 添加至双向链表的头部</span><br><span class="hljs-title">            addToHead</span>(<span class="hljs-keyword">node</span><span class="hljs-title">);</span><br><span class="hljs-title">            ++size</span>;<br>            if (size &gt; capacity) &#123;<br>                // 如果超出容量，删除双向链表的尾部节点<br>                DLinkedNode* removed = removeTail();<br>                // 删除哈希表中对应的项<br>                cache.erase(removed-&gt;key);<br>                // 防止内存泄漏<br>                delete removed;<br>                --size;<br>            &#125;<br>        &#125;<br>        else &#123;<br>            // 如果 key 存在，先通过哈希表定位，再修改 value，并移到头部<br>            DLinkedNode* <span class="hljs-keyword">node</span> <span class="hljs-title">= cache</span>[key];<br>            <span class="hljs-keyword">node</span><span class="hljs-title">-&gt;value</span> = value;<br>            moveToHead(<span class="hljs-keyword">node</span><span class="hljs-title">);</span><br><span class="hljs-title">        &#125;</span><br><span class="hljs-title">    &#125;</span><br><span class="hljs-title"></span><br><span class="hljs-title">    void</span> addToHead(DLinkedNode* <span class="hljs-keyword">node</span><span class="hljs-title">) &#123;</span><br><span class="hljs-title">        node-</span>&gt;prev = head;<br>        <span class="hljs-keyword">node</span><span class="hljs-title">-&gt;next</span> = head-&gt;next;<br>        head-&gt;next-&gt;prev = <span class="hljs-keyword">node</span><span class="hljs-title">;</span><br><span class="hljs-title">        head-</span>&gt;next = <span class="hljs-keyword">node</span><span class="hljs-title">;</span><br><span class="hljs-title">    &#125;</span><br><span class="hljs-title">    </span><br><span class="hljs-title">    void</span> removeNode(DLinkedNode* <span class="hljs-keyword">node</span><span class="hljs-title">) &#123;</span><br><span class="hljs-title">        node-</span>&gt;prev-&gt;next = <span class="hljs-keyword">node</span><span class="hljs-title">-&gt;next</span>;<br>        <span class="hljs-keyword">node</span><span class="hljs-title">-&gt;next-</span>&gt;prev = <span class="hljs-keyword">node</span><span class="hljs-title">-&gt;prev</span>;<br>    &#125;<br><br>    void moveToHead(DLinkedNode* <span class="hljs-keyword">node</span><span class="hljs-title">) &#123;</span><br><span class="hljs-title">        removeNode</span>(<span class="hljs-keyword">node</span><span class="hljs-title">);</span><br><span class="hljs-title">        addToHead</span>(<span class="hljs-keyword">node</span><span class="hljs-title">);</span><br><span class="hljs-title">    &#125;</span><br><span class="hljs-title"></span><br><span class="hljs-title">    DLinkedNode</span>* removeTail() &#123;<br>        DLinkedNode* <span class="hljs-keyword">node</span> <span class="hljs-title">= tail-</span>&gt;prev;<br>        removeNode(<span class="hljs-keyword">node</span><span class="hljs-title">);</span><br><span class="hljs-title">        return</span> <span class="hljs-keyword">node</span><span class="hljs-title">;</span><br><span class="hljs-title">    &#125;</span><br><span class="hljs-title">&#125;;</span><br></code></pre></td></tr></table></figure>

<p>手撕memcpy函数</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-type">void</span>* <span class="hljs-title">memcpy</span><span class="hljs-params">(<span class="hljs-type">void</span> *dst, <span class="hljs-type">const</span> <span class="hljs-type">void</span> *src, <span class="hljs-type">size_t</span> size)</span> </span>&#123;<br>    <span class="hljs-type">char</span> *psrc, *pdst;<br>    <span class="hljs-keyword">if</span> (dst == <span class="hljs-literal">NULL</span> || src == <span class="hljs-literal">NULL</span>) <br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-keyword">if</span> (dst &lt;= str) &#123;<br>        psrc = src;<br>        pdst = dst;<br>        <span class="hljs-keyword">while</span> (size--) <br>            *pdst++ = *psrc++;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        psrc = src + size - <span class="hljs-number">1</span>;<br>        pdst = dst + size - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (size--) &#123;<br>            *pdst-- = *psrc--;<br>    &#125;<br>    <span class="hljs-keyword">return</span> pdst;<br>&#125;<br><br></code></pre></td></tr></table></figure>


                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>嵌入式八股</div>
      <div>http://example.com/2024/05/06/嵌入式八股/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>Author</div>
          <div>John Doe</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>Posted on</div>
          <div>May 6, 2024</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>Licensed under</div>
          <div>
            
              
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - Attribution">
                    <i class="iconfont icon-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>Table of Contents</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">Search</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">Keyword</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">Blog works best with JavaScript enabled</div>
  </noscript>
</body>
</html>
