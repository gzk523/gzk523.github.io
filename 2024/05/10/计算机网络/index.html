<!DOCTYPE html><html lang="en" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>计算机网络 | Hexo</title><meta name="author" content="John Doe"><meta name="copyright" content="John Doe"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="计算机网络：HTTPS了解吗，讲讲TLS 流程，说HTTPS之前先说一下http协议，http协议是一种基于TCP协议的应用层传输协议，又因为HTTP在传输过程中是以明文形式传输，容易被攻击者窃听、篡改，HTTPS是在HTTP和TCP之间增加了一个SSL或者TLS安全传输协议，而HTTPS通过使用TLS或者SSL协议对数据进行加密和认证，提高了传输的安全性和保密性。TLS的流程：TLS也是通过客户">
<meta property="og:type" content="article">
<meta property="og:title" content="计算机网络">
<meta property="og:url" content="http://example.com/2024/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="计算机网络：HTTPS了解吗，讲讲TLS 流程，说HTTPS之前先说一下http协议，http协议是一种基于TCP协议的应用层传输协议，又因为HTTP在传输过程中是以明文形式传输，容易被攻击者窃听、篡改，HTTPS是在HTTP和TCP之间增加了一个SSL或者TLS安全传输协议，而HTTPS通过使用TLS或者SSL协议对数据进行加密和认证，提高了传输的安全性和保密性。TLS的流程：TLS也是通过客户">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png">
<meta property="article:published_time" content="2024-05-10T05:23:37.000Z">
<meta property="article:modified_time" content="2024-05-10T05:26:07.195Z">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2024/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=4.13.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.5.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: 'Copy Successful',
    error: 'Copy Error',
    noSupport: 'Browser Not Supported'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: 'Just now',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.11.1/dist/infinitegrid.min.js',
    buttonText: 'Load More'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '计算机网络',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-05-10 13:26:07'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 7.2.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">8</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">0</div></a></div><hr class="custom-hr"/></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog-info"><a href="/" title="Hexo"><span class="site-name">Hexo</span></a></span><div id="menus"><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">计算机网络</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2024-05-10T05:23:37.000Z" title="Created 2024-05-10 13:23:37">2024-05-10</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2024-05-10T05:26:07.195Z" title="Updated 2024-05-10 13:26:07">2024-05-10</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="计算机网络"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post Views:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="计算机网络："><a href="#计算机网络：" class="headerlink" title="计算机网络："></a>计算机网络：</h1><h2 id="HTTPS了解吗，讲讲TLS-流程，"><a href="#HTTPS了解吗，讲讲TLS-流程，" class="headerlink" title="HTTPS了解吗，讲讲TLS 流程，"></a>HTTPS了解吗，讲讲TLS 流程，</h2><p>说HTTPS之前先说一下http协议，http协议是一种基于TCP协议的应用层传输协议，又因为HTTP在传输过程中是以明文形式传输，容易被攻击者窃听、篡改，HTTPS是在HTTP和TCP之间增加了一个SSL或者TLS安全传输协议，而HTTPS通过使用TLS或者SSL协议对数据进行加密和认证，提高了传输的安全性和保密性。<br>TLS的流程：TLS也是通过客户端和服务器端之间的握手来保证数据传输的安全性的。</p>
<p>HTTPS流程<br>1：首先客户端向服务端发送一个请求，并且连接到服务端的443端口<br>2：之后，服务端会发送一个公钥(证书)过来<br>3：之后客户端解析这个公钥(证书)，查看这个证书是否有效，如果有效，那么就会生成一个随机值(这个随机值就是密钥)，之后用服务端发送过来的公钥来加密这个随机值<br>4：客户端发送这个加密过的随机值<br>5：服务端收到这个随机值之后，利用自己的私钥来解密，获得这个随机值，之后利用这个随机值来对称加密内容<br>6：之后就是http过程，进行传输数据<br>传输内容<br>客户端利用随机值来进行解密<br>这就是整个的过程</p>
<p>先非对称加密，在对称加密</p>
<p>TLS流程<br>TLS&#x2F;SSL 的功能实现主要依赖于三类基本算法：散列函数 、对称加密和非对称加密<br>其利用非对称加密实现身份认证和密钥协商，对称加密算法采用协商的密钥对数据加密，基于散列函数验证信息的完整性。<br>所以HTTPS是使用对称加密和非对称加密两者并用的混合加密机制。<br>具体做法是：发送密文的一方使用对方的公钥进行加密处理“对称的密钥”，然后对方用自己的私钥解密拿到“对称的密钥”，这样可以确保交换的密钥是安全的前提下，使用对称加密方式进行通信。</p>
<h2 id="HTTP的长连接和短连接"><a href="#HTTP的长连接和短连接" class="headerlink" title="HTTP的长连接和短连接"></a>HTTP的长连接和短连接</h2><p>HTTP协议的长连接和短连接，实质上是TCP协议的长连接和短连接。<br>在HTTP&#x2F;1.0中，默认使用的是短连接。也就是说，浏览器和服务器每进行一次HTTP操作，就建立一次连接，任务结束就中断连接，也就是访问同一个服务器上的每一个资源，就要建立一个TCP连接</p>
<p>但从 HTTP&#x2F;1.1起，默认使用长连接，用以保持连接特性。使用长连接的HTTP协议，会在请求和响应头加入这行代码：Connection:keep-alive，就表示只建立一次TCP连接，他有一个保持时间，可以继续利用这个TCP连接来传输HTTP数据</p>
<h2 id="hTTP的常用状态码："><a href="#hTTP的常用状态码：" class="headerlink" title="hTTP的常用状态码："></a>hTTP的常用状态码：</h2><p>1xx表示提示信息</p>
<p>2xx表示成功<br>200 ok（请求成功）<br>204 no content （请求成功，但是没有结果返回）<br>206 partial content （客户端请求一部分资源，服务端成功响应，返回一范围资源）</p>
<p>3xx表示重定向，网页或者资源位置发生变化，<br>301 move permanently （永久性重定向）<br>302 found （临时性重定向）<br>303 see other （示由于请求对应的资源存在着另一个 URI，应使用 GET方法定向获取请求的资源）<br>304 not modified （表示在客户端采用带条件的访问某资源时，服务端找到了资源，但是这个请求的条件不符合。跟重定向无关）<br>307 temporary redirect （跟302一个意思）</p>
<p>4xx表示客户端错误，请求报文有误<br>400 bad request （请求报文存在语法错误）<br>401 unauthorized （需要认证（第一次返回）或者认证失败（第二次返回））<br>403 forbidden （请求被服务器拒绝了）<br>404 not found （服务器上无法找到请求的资源）</p>
<p>5xx表示服务器错误<br>500 internal server error （服务端执行请求时发生了错误）<br>503 service unavailable （服务器正在超负载或者停机维护，无法处理请求）</p>
<h2 id="http中的get、post区别"><a href="#http中的get、post区别" class="headerlink" title="http中的get、post区别"></a>http中的get、post区别</h2><p>GET和POST请求都是http的请求方式，用户通过不同的http的请求方式完成对资源（url）的不同操作。具体点来讲GET一般用于获取&#x2F;查询资源信息，而POST一般用于更新资源信息。<br>1、Get请求提交的数据会在地址栏显示出来，而post请求不会再地址栏显示出来，<br>2、传输数据的大小：Get请求由于浏览器对地址长度的限制而导致传输的数据有限制(因为他要将数据在地址栏显示出来)。而POST请求不会因为地址长度限制而导致传输数据限制。<br>3、安全性,POST的安全性要比GET的安全性高。由于数据是会在地址中呈现，所以可以通过历史记录找到密码等关键信息。</p>
<h2 id="http版本也很多了，http2和1-1有什么优势呢"><a href="#http版本也很多了，http2和1-1有什么优势呢" class="headerlink" title="http版本也很多了，http2和1.1有什么优势呢"></a>http版本也很多了，http2和1.1有什么优势呢</h2><p>多路复用（Multiplexing）：<br>在 HTTP&#x2F;1.1 中，每个请求都需要通过单独的 TCP 连接发送，导致了”队头阻塞”的问题，即一个请求在等待时会阻塞后续请求的发送。<br>HTTP&#x2F;2 使用了多路复用技术，允许多个请求同时通过同一个 TCP 连接发送和接收，解决了队头阻塞的问题，提高了并发性能。<br>流量控制（Flow Control）：<br>在 HTTP&#x2F;1.1 中，没有有效的机制来控制流量，可能导致服务器发送速度过快而导致客户端无法处理。<br>HTTP&#x2F;2 使用了流量控制机制，允许客户端和服务器之间进行流量控制，保证了数据的平稳传输，防止了过载的情况发生。</p>
<h2 id="http怎么进行传参"><a href="#http怎么进行传参" class="headerlink" title="http怎么进行传参"></a>http怎么进行传参</h2><p>HTTP 协议本身并没有提供传参的机制，但在实际应用中，常用的传参方式包括在 URL 中使用查询字符串（query string）、在请求体中使用表单数据等。以下是常见的 HTTP 传参方式：查询字符串(GET)和表单数据(POST)</p>
<p>查询字符串（Query String）：<br>查询字符串是指 URL 中问号后面的部分，例如 <a href="http://example.com/resource?param1=value1&param2=value2%E3%80%82">http://example.com/resource?param1=value1&amp;param2=value2。</a><br>查询字符串中的参数以键值对的形式出现，使用 key&#x3D;value 的格式，多个参数之间使用 &amp; 符号分隔。<br>查询字符串适用于 GET 请求，客户端将参数直接附加在 URL 中发送给服务器。</p>
<p>表单数据（Form Data）：<br>表单数据通常用于 POST 请求，客户端将参数放在请求体中以表单形式提交给服务器。<br>在 HTML 表单中，可以使用 <form> 标签包裹输入元素，用户填写表单后，提交时浏览器会将表单数据以键值对的形式发送给服务器。<br>服务器端可以通过解析请求体来获取表单数据，常见的编码方式包括 application&#x2F;x-www-form-urlencoded 和 multipart&#x2F;form-data。</p>
<h2 id="URI和URL的区别"><a href="#URI和URL的区别" class="headerlink" title="URI和URL的区别"></a>URI和URL的区别</h2><p>（1）URI(Uniform Resource Identifier)：统⼀资源标识符，可以唯⼀标识一个资源。<br>（2）URL(Uniform Resource Location)：统⼀资源定位符，可以提供该资源的路径。它是一种具体的URI，即URL可以⽤来标识一个资源，⽽且还指明了如何定位到这个资源。<br>（3）URI的作用像身份证号⼀样，URL的作用更像家庭住址⼀样。URL是⼀种具体的URI，它不仅唯一标识资源，⽽且还提供了定位该资源的信息。</p>
<h2 id="Cookie和Session的区别"><a href="#Cookie和Session的区别" class="headerlink" title="Cookie和Session的区别"></a>Cookie和Session的区别</h2><p>cookie和session是为了进行身份辨认的<br>保存位置不同，Cookie保存在客户端，Session保存在服务端；<br>隐私策略不同，Cookie 可以减轻服务器压力，但是不安全，容易进行Cookie 欺骗，Session较安全，但占用服务器资源；<br>有效期不同，Cookie 可设置为长时间保持，比如经常使用的默认登录功能，Session一般失效时间较短，客户端关闭或者Session超时都会失效。</p>
<h2 id="如果禁用cookie，session还能用吗"><a href="#如果禁用cookie，session还能用吗" class="headerlink" title="如果禁用cookie，session还能用吗"></a>如果禁用cookie，session还能用吗</h2><p>可以，Session的作用是在服务端保持状态，通过sessionid来进行确认身份，但sessionid一般是通过Cookie来进行传递的。如果Cooike被禁用了，可以通过在URL中传递sessionid。</p>
<h2 id="安全通信的四大原则"><a href="#安全通信的四大原则" class="headerlink" title="安全通信的四大原则"></a>安全通信的四大原则</h2><p>机密性，对数据进行加密<br>完整性：数据在传输过程中没有经过篡改<br>身份认证：确认对方的身份<br>不可否认：传输了之后，不能否认自己传输过数据</p>
<h2 id="CA-签发流程"><a href="#CA-签发流程" class="headerlink" title="CA 签发流程"></a>CA 签发流程</h2><p>1.申请认证, 2.审核信息, 3.签发证书 4.返回证书 5.验证证书 6.密钥协商 </p>
<h2 id="TCP分为三次握手和四次挥手："><a href="#TCP分为三次握手和四次挥手：" class="headerlink" title="TCP分为三次握手和四次挥手："></a>TCP分为三次握手和四次挥手：</h2><p>​	三次握手：</p>
<p>​	在TCP连接过程中为了建立端到端的连接，需要进行TCP的三次握手过程，首先，服务器处于监听阶段，客户端发来一个SYN包到服务器，表示自己想要建立连接，之后服务器会发送一个SYN和ACK包来确认收到请求并允许建立连接，之后客户端再发送一个ACK包表示已经收到服务器的回复，并同意建立可靠连接。</p>
<p>​	四次挥手：</p>
<p>​	首先客户端发送一个FIN包表示自己想要关闭连接，之后服务器会发送一个ACK确认包到客户端，表示同意关闭连接，之后等服务器向客户端传递的数据传输完毕之后，服务器再发送一个FIN+ACK包来表示自己的数据已经发送完毕，请求关闭连接，客户端再发送一个ACK确认包来回复服务器表示同意关闭</p>
<h2 id="TCP三次握手中的序号和确认序号有什么用？"><a href="#TCP三次握手中的序号和确认序号有什么用？" class="headerlink" title="TCP三次握手中的序号和确认序号有什么用？"></a>TCP三次握手中的序号和确认序号有什么用？</h2><p>保证了接受数据的完整性和有序性</p>
<p>如何保证完整性的？<br>当生成了一个序号并随着TCP报文段发送出去之后，服务端要发送一个确认号回来，这个确认号表示下一个想要接收到的序号，如果接收到的不是这个序号的报文段，那么就丢弃</p>
<h2 id="TCP与UDP的区别："><a href="#TCP与UDP的区别：" class="headerlink" title="TCP与UDP的区别："></a>TCP与UDP的区别：</h2><p>TCP是面向连接的，UDP是无连接的<br>TCP是可靠的，UDP是不可靠的<br>TCP是面向字节流的，UDP是面向数据报文的<br>TCP只支持点对点通信，UDP支持一对一，一对多，多对多<br>TCP报文首部20个字节，UDP首部8个字节<br>TCP有拥塞控制机制，UDP没有</p>
<h2 id="讲一下向某个网站从发送请求到收到数据这个过程中发生的事情。"><a href="#讲一下向某个网站从发送请求到收到数据这个过程中发生的事情。" class="headerlink" title="讲一下向某个网站从发送请求到收到数据这个过程中发生的事情。"></a>讲一下向某个网站从发送请求到收到数据这个过程中发生的事情。</h2><p>浏览器进行DNS域名解析，得到对应的IP地址<br>根据这个IP和默认端口80，和对应的服务器建立TCP连接（三次握手）<br>建立TCP连接后发起HTTP请求（一个完整的http请求报文）<br>服务器响应HTTP请求，浏览器得到html代码（服务器如何响应）<br>浏览器解析html代码，并请求html代码中的资源（如js、css、图片等）<br>浏览器对页面进行渲染呈现给用户<br>服务器关闭TCP连接（四次挥手）</p>
<h2 id="http和htpps的区别"><a href="#http和htpps的区别" class="headerlink" title="http和htpps的区别"></a>http和htpps的区别</h2><p>  HTTP和HTTPS是用于在客户端和服务器之间传输数据的两种协议。它们的主要区别在于安全性和加密方面：</p>
<pre><code>    1. `安全性`：HTTP是一种不安全的协议，数据在传输过程中以明文形式传输，容易被攻击者窃听、篡改或伪装。而HTTPS通过使用TLS（Transport Layer Security）或SSL（Secure Sockets Layer）协议对数据进行加密和认证，提供了更高的安全性和保密性。
    2. . `加密通信`：HTTP不提供数据的加密传输，使得敏感信息（如登录凭据、信用卡号等）容易被攻击者获取。而HTTPS使用SSL/TLS协议对通信进行加密，确保数据在传输过程中的机密性，使得攻击者无法轻易获取敏感信息。
    3. `证书验证`：HTTPS使用SSL/TLS证书对服务器进行身份验证，确保客户端与服务器之间的通信建立在可信任的连接上。客户端会验证服务器的证书，以确保与合法和受信任的服务器建立连接。这样可以防止中间人攻击和DNS劫持等安全威胁。
    4.  `默认端口`：HTTP使用端口号80进行通信，而HTTPS使用端口号443进行加密通信。
</code></pre>
<p>  HTTPS在保护用户隐私和数据安全方面比HTTP更加可靠，因此在需要保护敏感信息的场景，如电子商务网站、在线支付平台等，推荐使用HTTPS。</p>
<h2 id="http没那么安全的例子？"><a href="#http没那么安全的例子？" class="headerlink" title="http没那么安全的例子？"></a>http没那么安全的例子？</h2><p>因为HTTP来传输的时候是使用明文来进行传输的，而明文很容易就被心怀不轨者所窃听，篡改或伪装，所以http并不安全</p>
<h2 id="tcp三次握手和四次挥手的过程中，双端是怎样变化的"><a href="#tcp三次握手和四次挥手的过程中，双端是怎样变化的" class="headerlink" title="tcp三次握手和四次挥手的过程中，双端是怎样变化的"></a>tcp三次握手和四次挥手的过程中，双端是怎样变化的</h2><p>三次握手：<br>1.客户端向服务器发送SYN包，并进入SYN_SENT状态，等待服务器确认；</p>
<p>2.服务器收到SYN包并进行确认，同时向客户端发送SYN包，即SYN+ACK包。此时服务器进入SYN_RECV状态。</p>
<p>3.客户端收到服务器的SYN+ACK包后，向服务器发送确认包ACK，发送完毕后，TCP连接成功，完成三次握手。</p>
<p>四次挥手：<br>1.首先客户端发送一个FIN包表示自己想要关闭连接，客户端进入FIN_CLOSE1状态<br>2之后服务器会发送一个ACK确认包到客户端，表示同意关闭连接，服务器进入CLOSE_WAIT状态，客户端进入FIN_CLOSE2状态<br>3之后等服务器向客户端传递的数据传输完毕之后，服务器再发送一个FIN+ACK包来表示自己的数据已经发送完毕，请求关闭连接，服务器进入LAST_ACK状态<br>4客户端再发送一个ACK确认包来回复服务器表示同意关闭，客户端进入TIME_WAIT状态</p>
<h2 id="FIN标记一定要程序执行close-或者shutdown-才能发出吗"><a href="#FIN标记一定要程序执行close-或者shutdown-才能发出吗" class="headerlink" title="FIN标记一定要程序执行close()或者shutdown()才能发出吗"></a>FIN标记一定要程序执行close()或者shutdown()才能发出吗</h2><p>不一定。一般情况下，通过对socket执行close() 或shutdown()方法会发出FIN。<br>但实际上，只要应用程序退出，不管是主动退出，还是被动退出（因为一些莫名其妙的原因被kill了）, 都会发出FIN。FIN 是指”我不再发送数据”，因此shutdown()关闭读不会给对方发FIN, 关闭写才会发FIN。</p>
<h2 id="TCP挥手可以三次吗，两次可以吗"><a href="#TCP挥手可以三次吗，两次可以吗" class="headerlink" title="TCP挥手可以三次吗，两次可以吗"></a>TCP挥手可以三次吗，两次可以吗</h2><p>都可以<br>挥手三次：如果被动关闭方没有数据要发送时，那么第二次挥手和第三次挥手可以合并，合并之后就是三次挥手了</p>
<p>挥手两次：如果客户端和服务端的IP和端口都是一样的</p>
<h2 id="黑客想要通过TCP攻击，会如何攻击，应该怎样应对"><a href="#黑客想要通过TCP攻击，会如何攻击，应该怎样应对" class="headerlink" title="黑客想要通过TCP攻击，会如何攻击，应该怎样应对"></a>黑客想要通过TCP攻击，会如何攻击，应该怎样应对</h2><p>因为TCP需要经过三次握手过程才可以建立连接，黑客们一般会通过伪装大量的IP地址给服务器发送SYN请求连接报文，但是由于IP地址不存在，因此当服务器给客户端发送回确认之后，由于一直收不到确认，会一直处于SYN_RECV状态，服务器会将IP放入等待队列，并重发确认报文，而由于攻击者发送了大量的请求报文，会导致服务器要维持一个很大的等待队列，导致服务器崩溃</p>
<h2 id="讲一下三次握手，两次行不行"><a href="#讲一下三次握手，两次行不行" class="headerlink" title="讲一下三次握手，两次行不行"></a>讲一下三次握手，两次行不行</h2><p>两次握手相比较于三次握手可能会出现一些问题，最主要的原因在于三次握手可以避免重复历史连接<br>主要是两次握手在服务端收到客户端发来的请求连接报文后，就会立即建立连接，而这可能会导致一些迟来的请求连接造成无效的连接，浪费资源。</p>
<h2 id="讲一下time-wait状态"><a href="#讲一下time-wait状态" class="headerlink" title="讲一下time_wait状态"></a>讲一下time_wait状态</h2><p>time_wait是客户端在收到服务器发来数据已经传送完成并且请求关闭连接之后，客户端发送确认报文，就进入了time_wait状态，这个状态主要是为了保证连接正确关闭，例如当主动关闭方发送的确认报文丢失了，那么被动方会重新发送一个请求报文，所以设置一个time_wait是有必要的<br>另外，如果不设置这个time_wait当又有新的连接在这两个端口连接时，如果有上一个链接迟来的报文到达，会导致数据错乱(可以保证旧连接重复分组已经在网络中消逝)</p>
<h2 id="那假设A服务器开了8080端口，B服务器用什么命令去访问"><a href="#那假设A服务器开了8080端口，B服务器用什么命令去访问" class="headerlink" title="那假设A服务器开了8080端口，B服务器用什么命令去访问"></a>那假设A服务器开了8080端口，B服务器用什么命令去访问</h2><p>可以使用netstat来查看哪些端口被打开<br>可以直接使用ssh来直接登录b服务器</p>
<h2 id="了解滑动窗口吗"><a href="#了解滑动窗口吗" class="headerlink" title="了解滑动窗口吗"></a>了解滑动窗口吗</h2><p>TCP的滑动窗口是一种核心的流量控制机制。它基于窗口的概念，窗口实际上是一个缓冲区，在这个缓冲区内，发送方被允许在未收到确认的情况下连续发送数据，其中发送窗口就表示接收方还剩下多少接收缓冲<br>滑动窗口分为三类：停止等待、后退N帧、选择重传，他们之间的区别就在于发送窗口和接收窗口的区别，<br>停止等待：发送窗口&#x3D;1，接收窗口&#x3D;1<br>后退N帧：发送窗口&gt;&#x3D;1，接收窗口&#x3D;1，允许在未收到确认帧时发送后面的帧，但是当接收方发现接收到错误帧，那么后面发来的全部帧全部不要<br>选择重传：发送窗口&gt;&#x3D;1,接收窗口&gt;&#x3D;1，在后退N帧基础上，在缓存中保存了错误帧后面的帧，等到重传的正确帧到来后一起上传</p>
<h2 id="那你讲一下拥塞控制的方法"><a href="#那你讲一下拥塞控制的方法" class="headerlink" title="那你讲一下拥塞控制的方法"></a>那你讲一下拥塞控制的方法</h2><p>慢开始，拥塞避免，快重传，快恢复<br>慢开始是指在传输刚开始时，拥塞窗口&#x3D;1，然后发送方每收到一个确认报文，拥塞窗口都会加一，为了防止拥塞窗口过大而导致网络拥塞，设置一个慢开始门限，小于门限使用满开始，高于门限，则使用拥塞避免，表示拥塞窗口每次只加一<br>当遇到拥塞时，门限减为原来的一半，拥塞窗口从1开始<br>快重传表示如果发送方连续接收到了3个重复确认，那么立即重传要求的报文<br>快恢复表示在快重传之后，不是执行慢开始而是执行快恢复，将拥塞窗口和门限都除以二，执行拥塞避免</p>
<h2 id="拥塞控制与流量控制："><a href="#拥塞控制与流量控制：" class="headerlink" title="拥塞控制与流量控制："></a>拥塞控制与流量控制：</h2><p>拥塞控制是一种全局的问题，而流量控制往往指点到点通信量的控制，是一种端到端的</p>
<h2 id="RPC是什么"><a href="#RPC是什么" class="headerlink" title="RPC是什么"></a>RPC是什么</h2><p>RPC（Remote Procedure Call）远程过程调用协议，一种通过网络从远程计算机上请求服务，而不需要了解底层网络技术的协议。在OSI网络七层模型中，RPC跨越了传输层和应用层。</p>
<h2 id="arp协议"><a href="#arp协议" class="headerlink" title="arp协议"></a>arp协议</h2><p>是一个数据链路层协议，数据链路层使用arp协议来进行寻址，当数据链路层收到了网络层传下来的数据包后，根据IP地址，首先查看自己的arp缓存中有没有目的IP地址对应的MAC地址，如果有，那么就利用这个MAC地址建立通信，如果没有，那么就向局域网内发送arp请求广播，局域网内所有的主机都能听到，局域网内的主机检查发来的arp广播中的目的IP地址是否与自己的IP地址一致，如果一致，那么主机就发送一个ARP响应，包含自己的MAC地址，这个响应也是以广播方式发送，请求主机收到响应后，他将更新arp缓存，将目标IP地址和MAC地址更新，之后就根据MAC地址建立连接</p>
<h2 id="ip协议"><a href="#ip协议" class="headerlink" title="ip协议"></a>ip协议</h2><p>在网络层使用ip协议来进行寻址，ip地址是分配给计算机或者网络设备的唯一标识符，在IP协议中，每个数据包中都包含目的地址和源地址，使得数据能够在网络中正确的传递</p>
<h2 id="TCP是可靠传输，我们在编程的时候相比UDP是不是要绑定端口这些？"><a href="#TCP是可靠传输，我们在编程的时候相比UDP是不是要绑定端口这些？" class="headerlink" title="TCP是可靠传输，我们在编程的时候相比UDP是不是要绑定端口这些？"></a>TCP是可靠传输，我们在编程的时候相比UDP是不是要绑定端口这些？</h2><p>在使用socket编程时：<br>无论是TCP还是UDP，在编程时都需要绑定端口，这是因为套接字（Socket）通信是通过端口来识别应用程序和服务的。<br>无论是TCP还是UDP编程，通常都需要进行以下步骤：</p>
<p>创建套接字：使用socket()函数创建套接字。<br>绑定端口：使用bind()函数将套接字绑定到特定的端口上，这样其他程序就可以通过指定的端口来与该程序通信。<br>监听连接（仅适用于TCP）：如果是TCP编程，还需要调用listen()函数开始监听传入的连接请求。<br>接受连接（仅适用于TCP）：如果是TCP编程，还需要调用accept()函数接受传入的连接请求，建立连接。<br>发送和接收数据：使用send()和recv()（或者sendto()和recvfrom()）函数进行数据的发送和接收。<br>在TCP编程中，因为TCP是面向连接的协议，所以需要额外的步骤来监听连接和接受连接，这些步骤不适用于UDP编程。但是无论是TCP还是UDP，都需要在编程中绑定端口，以便程序能够通过特定的端口进行通信。</p>
<h2 id="socket编程，TCP和UDP在API层面主要有哪些区别？"><a href="#socket编程，TCP和UDP在API层面主要有哪些区别？" class="headerlink" title="socket编程，TCP和UDP在API层面主要有哪些区别？"></a>socket编程，TCP和UDP在API层面主要有哪些区别？</h2><p>首先在创建套接字时，利用socket函数，TCP使用sock_STREAM参数，UDP使用SOCK_DGRAM参数<br>tcp需要使用connect函数来建立链接，UDP不需要建立连接，直接发送制定目标IP地址和端口号<br>TCP使用send函数发送数据，UDP使用sendto函数发送数据<br>TCP使用recv函数接收数据，UDP使用recvfrom函数接收数据</p>
<h2 id="TCP是怎么实现可靠传输的"><a href="#TCP是怎么实现可靠传输的" class="headerlink" title="TCP是怎么实现可靠传输的"></a>TCP是怎么实现可靠传输的</h2><p>TCP的三次握手，四次挥手<br>TCP提供了检验和，并且有序列号和确认应答机制<br>TCP有拥塞控制和滑动窗口机制</p>
<h2 id="非对称加密算法和对称加密算法"><a href="#非对称加密算法和对称加密算法" class="headerlink" title="非对称加密算法和对称加密算法"></a>非对称加密算法和对称加密算法</h2><p>对称密码体制设计和实现的中心是: 用何种方法产生满足保密要求的密钥以及用何种方法将密钥安全又可靠地分配给通信双方。对称密码体制可以通过分组密码或流密码来实现，它既可以用于数据加密，又可以用于消息认证。<br>非对称密码体制使用公钥加密消息，使用私钥来解密。使用非对称密码体制可增强通信的安全性。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>Author: </span><span class="post-copyright-info"><a href="http://example.com">John Doe</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>Link: </span><span class="post-copyright-info"><a href="http://example.com/2024/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">http://example.com/2024/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2024/05/10/Linux/" title="Linux"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">Previous</div><div class="prev_info">Linux</div></div></a></div><div class="next-post pull-right"><a href="/2024/05/06/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%85%AB%E8%82%A1/" title="嵌入式八股"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">Next</div><div class="next_info">嵌入式八股</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">John Doe</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">8</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>Announcement</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Contents</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%EF%BC%9A"><span class="toc-number">1.</span> <span class="toc-text">计算机网络：</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#HTTPS%E4%BA%86%E8%A7%A3%E5%90%97%EF%BC%8C%E8%AE%B2%E8%AE%B2TLS-%E6%B5%81%E7%A8%8B%EF%BC%8C"><span class="toc-number">1.1.</span> <span class="toc-text">HTTPS了解吗，讲讲TLS 流程，</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HTTP%E7%9A%84%E9%95%BF%E8%BF%9E%E6%8E%A5%E5%92%8C%E7%9F%AD%E8%BF%9E%E6%8E%A5"><span class="toc-number">1.2.</span> <span class="toc-text">HTTP的长连接和短连接</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#hTTP%E7%9A%84%E5%B8%B8%E7%94%A8%E7%8A%B6%E6%80%81%E7%A0%81%EF%BC%9A"><span class="toc-number">1.3.</span> <span class="toc-text">hTTP的常用状态码：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#http%E4%B8%AD%E7%9A%84get%E3%80%81post%E5%8C%BA%E5%88%AB"><span class="toc-number">1.4.</span> <span class="toc-text">http中的get、post区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#http%E7%89%88%E6%9C%AC%E4%B9%9F%E5%BE%88%E5%A4%9A%E4%BA%86%EF%BC%8Chttp2%E5%92%8C1-1%E6%9C%89%E4%BB%80%E4%B9%88%E4%BC%98%E5%8A%BF%E5%91%A2"><span class="toc-number">1.5.</span> <span class="toc-text">http版本也很多了，http2和1.1有什么优势呢</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#http%E6%80%8E%E4%B9%88%E8%BF%9B%E8%A1%8C%E4%BC%A0%E5%8F%82"><span class="toc-number">1.6.</span> <span class="toc-text">http怎么进行传参</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#URI%E5%92%8CURL%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.7.</span> <span class="toc-text">URI和URL的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Cookie%E5%92%8CSession%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.8.</span> <span class="toc-text">Cookie和Session的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E6%9E%9C%E7%A6%81%E7%94%A8cookie%EF%BC%8Csession%E8%BF%98%E8%83%BD%E7%94%A8%E5%90%97"><span class="toc-number">1.9.</span> <span class="toc-text">如果禁用cookie，session还能用吗</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%89%E5%85%A8%E9%80%9A%E4%BF%A1%E7%9A%84%E5%9B%9B%E5%A4%A7%E5%8E%9F%E5%88%99"><span class="toc-number">1.10.</span> <span class="toc-text">安全通信的四大原则</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#CA-%E7%AD%BE%E5%8F%91%E6%B5%81%E7%A8%8B"><span class="toc-number">1.11.</span> <span class="toc-text">CA 签发流程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TCP%E5%88%86%E4%B8%BA%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%92%8C%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B%EF%BC%9A"><span class="toc-number">1.12.</span> <span class="toc-text">TCP分为三次握手和四次挥手：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E4%B8%AD%E7%9A%84%E5%BA%8F%E5%8F%B7%E5%92%8C%E7%A1%AE%E8%AE%A4%E5%BA%8F%E5%8F%B7%E6%9C%89%E4%BB%80%E4%B9%88%E7%94%A8%EF%BC%9F"><span class="toc-number">1.13.</span> <span class="toc-text">TCP三次握手中的序号和确认序号有什么用？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TCP%E4%B8%8EUDP%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9A"><span class="toc-number">1.14.</span> <span class="toc-text">TCP与UDP的区别：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%B2%E4%B8%80%E4%B8%8B%E5%90%91%E6%9F%90%E4%B8%AA%E7%BD%91%E7%AB%99%E4%BB%8E%E5%8F%91%E9%80%81%E8%AF%B7%E6%B1%82%E5%88%B0%E6%94%B6%E5%88%B0%E6%95%B0%E6%8D%AE%E8%BF%99%E4%B8%AA%E8%BF%87%E7%A8%8B%E4%B8%AD%E5%8F%91%E7%94%9F%E7%9A%84%E4%BA%8B%E6%83%85%E3%80%82"><span class="toc-number">1.15.</span> <span class="toc-text">讲一下向某个网站从发送请求到收到数据这个过程中发生的事情。</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#http%E5%92%8Chtpps%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.16.</span> <span class="toc-text">http和htpps的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#http%E6%B2%A1%E9%82%A3%E4%B9%88%E5%AE%89%E5%85%A8%E7%9A%84%E4%BE%8B%E5%AD%90%EF%BC%9F"><span class="toc-number">1.17.</span> <span class="toc-text">http没那么安全的例子？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#tcp%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%92%8C%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B%E7%9A%84%E8%BF%87%E7%A8%8B%E4%B8%AD%EF%BC%8C%E5%8F%8C%E7%AB%AF%E6%98%AF%E6%80%8E%E6%A0%B7%E5%8F%98%E5%8C%96%E7%9A%84"><span class="toc-number">1.18.</span> <span class="toc-text">tcp三次握手和四次挥手的过程中，双端是怎样变化的</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#FIN%E6%A0%87%E8%AE%B0%E4%B8%80%E5%AE%9A%E8%A6%81%E7%A8%8B%E5%BA%8F%E6%89%A7%E8%A1%8Cclose-%E6%88%96%E8%80%85shutdown-%E6%89%8D%E8%83%BD%E5%8F%91%E5%87%BA%E5%90%97"><span class="toc-number">1.19.</span> <span class="toc-text">FIN标记一定要程序执行close()或者shutdown()才能发出吗</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TCP%E6%8C%A5%E6%89%8B%E5%8F%AF%E4%BB%A5%E4%B8%89%E6%AC%A1%E5%90%97%EF%BC%8C%E4%B8%A4%E6%AC%A1%E5%8F%AF%E4%BB%A5%E5%90%97"><span class="toc-number">1.20.</span> <span class="toc-text">TCP挥手可以三次吗，两次可以吗</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%BB%91%E5%AE%A2%E6%83%B3%E8%A6%81%E9%80%9A%E8%BF%87TCP%E6%94%BB%E5%87%BB%EF%BC%8C%E4%BC%9A%E5%A6%82%E4%BD%95%E6%94%BB%E5%87%BB%EF%BC%8C%E5%BA%94%E8%AF%A5%E6%80%8E%E6%A0%B7%E5%BA%94%E5%AF%B9"><span class="toc-number">1.21.</span> <span class="toc-text">黑客想要通过TCP攻击，会如何攻击，应该怎样应对</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%B2%E4%B8%80%E4%B8%8B%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%EF%BC%8C%E4%B8%A4%E6%AC%A1%E8%A1%8C%E4%B8%8D%E8%A1%8C"><span class="toc-number">1.22.</span> <span class="toc-text">讲一下三次握手，两次行不行</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%B2%E4%B8%80%E4%B8%8Btime-wait%E7%8A%B6%E6%80%81"><span class="toc-number">1.23.</span> <span class="toc-text">讲一下time_wait状态</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%82%A3%E5%81%87%E8%AE%BEA%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%BC%80%E4%BA%868080%E7%AB%AF%E5%8F%A3%EF%BC%8CB%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%94%A8%E4%BB%80%E4%B9%88%E5%91%BD%E4%BB%A4%E5%8E%BB%E8%AE%BF%E9%97%AE"><span class="toc-number">1.24.</span> <span class="toc-text">那假设A服务器开了8080端口，B服务器用什么命令去访问</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%86%E8%A7%A3%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E5%90%97"><span class="toc-number">1.25.</span> <span class="toc-text">了解滑动窗口吗</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%82%A3%E4%BD%A0%E8%AE%B2%E4%B8%80%E4%B8%8B%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-number">1.26.</span> <span class="toc-text">那你讲一下拥塞控制的方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6%E4%B8%8E%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6%EF%BC%9A"><span class="toc-number">1.27.</span> <span class="toc-text">拥塞控制与流量控制：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#RPC%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">1.28.</span> <span class="toc-text">RPC是什么</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#arp%E5%8D%8F%E8%AE%AE"><span class="toc-number">1.29.</span> <span class="toc-text">arp协议</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ip%E5%8D%8F%E8%AE%AE"><span class="toc-number">1.30.</span> <span class="toc-text">ip协议</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TCP%E6%98%AF%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93%EF%BC%8C%E6%88%91%E4%BB%AC%E5%9C%A8%E7%BC%96%E7%A8%8B%E7%9A%84%E6%97%B6%E5%80%99%E7%9B%B8%E6%AF%94UDP%E6%98%AF%E4%B8%8D%E6%98%AF%E8%A6%81%E7%BB%91%E5%AE%9A%E7%AB%AF%E5%8F%A3%E8%BF%99%E4%BA%9B%EF%BC%9F"><span class="toc-number">1.31.</span> <span class="toc-text">TCP是可靠传输，我们在编程的时候相比UDP是不是要绑定端口这些？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#socket%E7%BC%96%E7%A8%8B%EF%BC%8CTCP%E5%92%8CUDP%E5%9C%A8API%E5%B1%82%E9%9D%A2%E4%B8%BB%E8%A6%81%E6%9C%89%E5%93%AA%E4%BA%9B%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">1.32.</span> <span class="toc-text">socket编程，TCP和UDP在API层面主要有哪些区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TCP%E6%98%AF%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93%E7%9A%84"><span class="toc-number">1.33.</span> <span class="toc-text">TCP是怎么实现可靠传输的</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95%E5%92%8C%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95"><span class="toc-number">1.34.</span> <span class="toc-text">非对称加密算法和对称加密算法</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>Recent Post</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/05/10/%E9%A1%B9%E7%9B%AE/" title="项目">项目</a><time datetime="2024-05-10T05:35:08.000Z" title="Created 2024-05-10 13:35:08">2024-05-10</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/05/10/C/" title="C++">C++</a><time datetime="2024-05-10T05:32:38.000Z" title="Created 2024-05-10 13:32:38">2024-05-10</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/05/10/Mysql/" title="Mysql">Mysql</a><time datetime="2024-05-10T05:31:54.000Z" title="Created 2024-05-10 13:31:54">2024-05-10</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/05/10/%E5%B5%8C%E5%85%A5%E5%BC%8F/" title="嵌入式">嵌入式</a><time datetime="2024-05-10T05:30:42.000Z" title="Created 2024-05-10 13:30:42">2024-05-10</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/05/10/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" title="操作系统">操作系统</a><time datetime="2024-05-10T05:27:52.000Z" title="Created 2024-05-10 13:27:52">2024-05-10</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2024 By John Doe</div><div class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Read Mode"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="Toggle Between Light And Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle between Single-column and Double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="Setting"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table Of Contents"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="Back To Top"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=4.13.0"></script><script src="/js/main.js?v=4.13.0"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>